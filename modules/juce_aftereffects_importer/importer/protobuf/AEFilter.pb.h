#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#pragma clang diagnostic ignored "-Wshorten-64-to-32" //not available on all gcc platforms
#elif defined(__GNUC__) || defined(__GNUG__) //also defined with clang, must be second
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#elif defined(_MSC_VER)
#pragma warning (push, 0)
#endif
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AEFilter.proto

#ifndef PROTOBUF_AEFilter_2eproto__INCLUDED
#define PROTOBUF_AEFilter_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace aefilter {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AEFilter_2eproto();
void protobuf_AssignDesc_AEFilter_2eproto();
void protobuf_ShutdownFile_AEFilter_2eproto();

class AEVector;
class AEColor;
class AETransform;
class AEKeyPair;
class AETextInfo;
class AEMaskVertex;
class AEMask;
class AEEffectParam;
class AEEffect;
class AELayer;
class AECamera;
class AELight;
class AETrackIdentifier;
class AEComposition;
class AESource;
class AELayout;
class AEKeytimeEase;
class AEKeytime;
class AETrack;
class AEMarker;
class AETimeline;

enum AESourceType {
  AE_COMP_SRC = 0,
  AE_IMAGE_SRC = 1,
  AE_SOLID_SRC = 2,
  AE_NULL_SRC = 3,
  AE_IMAGE_NPATCH_SRC = 4,
  AE_MASK_SRC = 5,
  AE_SRC_NONE = 6,
  AE_SPRITE_SRC = 7,
  AE_ADJUSTMENT_SRC = 8,
  AE_FONT_SRC = 9
};
bool AESourceType_IsValid(int value);
const AESourceType AESourceType_MIN = AE_COMP_SRC;
const AESourceType AESourceType_MAX = AE_FONT_SRC;
const int AESourceType_ARRAYSIZE = AESourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AESourceType_descriptor();
inline const ::std::string& AESourceType_Name(AESourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AESourceType_descriptor(), value);
}
inline bool AESourceType_Parse(
    const ::std::string& name, AESourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AESourceType>(
    AESourceType_descriptor(), name, value);
}
enum AEJustificationType {
  AE_TEXT_UNSUPPORTED = -1,
  AE_TEXT_LEFT = 0,
  AE_TEXT_RIGHT = 1,
  AE_TEXT_CENTER = 2
};
bool AEJustificationType_IsValid(int value);
const AEJustificationType AEJustificationType_MIN = AE_TEXT_UNSUPPORTED;
const AEJustificationType AEJustificationType_MAX = AE_TEXT_CENTER;
const int AEJustificationType_ARRAYSIZE = AEJustificationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AEJustificationType_descriptor();
inline const ::std::string& AEJustificationType_Name(AEJustificationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AEJustificationType_descriptor(), value);
}
inline bool AEJustificationType_Parse(
    const ::std::string& name, AEJustificationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AEJustificationType>(
    AEJustificationType_descriptor(), name, value);
}
enum AELightType {
  AE_LIGHT_PARALLEL = 0,
  AE_LIGHT_SPOT = 1,
  AE_LIGHT_POINT = 2,
  AE_LIGHT_AMBIENT = 3
};
bool AELightType_IsValid(int value);
const AELightType AELightType_MIN = AE_LIGHT_PARALLEL;
const AELightType AELightType_MAX = AE_LIGHT_AMBIENT;
const int AELightType_ARRAYSIZE = AELightType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AELightType_descriptor();
inline const ::std::string& AELightType_Name(AELightType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AELightType_descriptor(), value);
}
inline bool AELightType_Parse(
    const ::std::string& name, AELightType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AELightType>(
    AELightType_descriptor(), name, value);
}
enum AEBinding {
  POSITION = 0,
  ROTATION_X = 1,
  ROTATION_Y = 2,
  ROTATION_Z = 3,
  ORIENTATION = 4,
  SCALE = 5,
  OPACITY = 6,
  SEP_POSITION_X = 7,
  SEP_POSITION_Y = 8,
  SEP_POSITION_Z = 9,
  IS_VISIBLE = 10,
  ANCHOR_POINT = 11,
  CUSTOM = 12,
  BINDING_MAX = 13
};
bool AEBinding_IsValid(int value);
const AEBinding AEBinding_MIN = POSITION;
const AEBinding AEBinding_MAX = BINDING_MAX;
const int AEBinding_ARRAYSIZE = AEBinding_MAX + 1;

const ::google::protobuf::EnumDescriptor* AEBinding_descriptor();
inline const ::std::string& AEBinding_Name(AEBinding value) {
  return ::google::protobuf::internal::NameOfEnum(
    AEBinding_descriptor(), value);
}
inline bool AEBinding_Parse(
    const ::std::string& name, AEBinding* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AEBinding>(
    AEBinding_descriptor(), name, value);
}
enum AEDataType {
  AE_FLOAT_DATA = 0,
  AE_FLOAT_VECTOR_DATA = 1,
  AE_INT_DATA = 2,
  AE_QUATERNION_DATA = 3
};
bool AEDataType_IsValid(int value);
const AEDataType AEDataType_MIN = AE_FLOAT_DATA;
const AEDataType AEDataType_MAX = AE_QUATERNION_DATA;
const int AEDataType_ARRAYSIZE = AEDataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AEDataType_descriptor();
inline const ::std::string& AEDataType_Name(AEDataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AEDataType_descriptor(), value);
}
inline bool AEDataType_Parse(
    const ::std::string& name, AEDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AEDataType>(
    AEDataType_descriptor(), name, value);
}
enum AEIType {
  AE_INTERP_NONE = 0,
  AE_INTERP_LINEAR = 1,
  AE_INTERP_BEZIER = 2,
  AE_INTERP_HOLD = 3
};
bool AEIType_IsValid(int value);
const AEIType AEIType_MIN = AE_INTERP_NONE;
const AEIType AEIType_MAX = AE_INTERP_HOLD;
const int AEIType_ARRAYSIZE = AEIType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AEIType_descriptor();
inline const ::std::string& AEIType_Name(AEIType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AEIType_descriptor(), value);
}
inline bool AEIType_Parse(
    const ::std::string& name, AEIType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AEIType>(
    AEIType_descriptor(), name, value);
}
// ===================================================================

class AEVector : public ::google::protobuf::Message {
 public:
  AEVector();
  virtual ~AEVector();
  
  AEVector(const AEVector& from);
  
  inline AEVector& operator=(const AEVector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AEVector& default_instance();
  
  void Swap(AEVector* other);
  
  // implements Message ----------------------------------------------
  
  AEVector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEVector& from);
  void MergeFrom(const AEVector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);
  
  // @@protoc_insertion_point(class_scope:aefilter.AEVector)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float z_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AEVector* default_instance_;
};
// -------------------------------------------------------------------

class AEColor : public ::google::protobuf::Message {
 public:
  AEColor();
  virtual ~AEColor();
  
  AEColor(const AEColor& from);
  
  inline AEColor& operator=(const AEColor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AEColor& default_instance();
  
  void Swap(AEColor* other);
  
  // implements Message ----------------------------------------------
  
  AEColor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEColor& from);
  void MergeFrom(const AEColor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double alpha = 1;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  inline double alpha() const;
  inline void set_alpha(double value);
  
  // required double red = 2;
  inline bool has_red() const;
  inline void clear_red();
  static const int kRedFieldNumber = 2;
  inline double red() const;
  inline void set_red(double value);
  
  // required double green = 3;
  inline bool has_green() const;
  inline void clear_green();
  static const int kGreenFieldNumber = 3;
  inline double green() const;
  inline void set_green(double value);
  
  // required double blue = 4;
  inline bool has_blue() const;
  inline void clear_blue();
  static const int kBlueFieldNumber = 4;
  inline double blue() const;
  inline void set_blue(double value);
  
  // @@protoc_insertion_point(class_scope:aefilter.AEColor)
 private:
  inline void set_has_alpha();
  inline void clear_has_alpha();
  inline void set_has_red();
  inline void clear_has_red();
  inline void set_has_green();
  inline void clear_has_green();
  inline void set_has_blue();
  inline void clear_has_blue();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double alpha_;
  double red_;
  double green_;
  double blue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AEColor* default_instance_;
};
// -------------------------------------------------------------------

class AETransform : public ::google::protobuf::Message {
 public:
  AETransform();
  virtual ~AETransform();
  
  AETransform(const AETransform& from);
  
  inline AETransform& operator=(const AETransform& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AETransform& default_instance();
  
  void Swap(AETransform* other);
  
  // implements Message ----------------------------------------------
  
  AETransform* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AETransform& from);
  void MergeFrom(const AETransform& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .aefilter.AEVector anchorPoint = 1;
  inline bool has_anchorpoint() const;
  inline void clear_anchorpoint();
  static const int kAnchorPointFieldNumber = 1;
  inline const ::aefilter::AEVector& anchorpoint() const;
  inline ::aefilter::AEVector* mutable_anchorpoint();
  inline ::aefilter::AEVector* release_anchorpoint();
  
  // required .aefilter.AEVector scale = 2;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 2;
  inline const ::aefilter::AEVector& scale() const;
  inline ::aefilter::AEVector* mutable_scale();
  inline ::aefilter::AEVector* release_scale();
  
  // required .aefilter.AEVector position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::aefilter::AEVector& position() const;
  inline ::aefilter::AEVector* mutable_position();
  inline ::aefilter::AEVector* release_position();
  
  // required .aefilter.AEVector orientation = 4;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  inline const ::aefilter::AEVector& orientation() const;
  inline ::aefilter::AEVector* mutable_orientation();
  inline ::aefilter::AEVector* release_orientation();
  
  // required float rotationX = 5;
  inline bool has_rotationx() const;
  inline void clear_rotationx();
  static const int kRotationXFieldNumber = 5;
  inline float rotationx() const;
  inline void set_rotationx(float value);
  
  // required float rotationY = 6;
  inline bool has_rotationy() const;
  inline void clear_rotationy();
  static const int kRotationYFieldNumber = 6;
  inline float rotationy() const;
  inline void set_rotationy(float value);
  
  // required float rotationZ = 7;
  inline bool has_rotationz() const;
  inline void clear_rotationz();
  static const int kRotationZFieldNumber = 7;
  inline float rotationz() const;
  inline void set_rotationz(float value);
  
  // required float opacity = 8;
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 8;
  inline float opacity() const;
  inline void set_opacity(float value);
  
  // @@protoc_insertion_point(class_scope:aefilter.AETransform)
 private:
  inline void set_has_anchorpoint();
  inline void clear_has_anchorpoint();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_rotationx();
  inline void clear_has_rotationx();
  inline void set_has_rotationy();
  inline void clear_has_rotationy();
  inline void set_has_rotationz();
  inline void clear_has_rotationz();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::aefilter::AEVector* anchorpoint_;
  ::aefilter::AEVector* scale_;
  ::aefilter::AEVector* position_;
  ::aefilter::AEVector* orientation_;
  float rotationx_;
  float rotationy_;
  float rotationz_;
  float opacity_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AETransform* default_instance_;
};
// -------------------------------------------------------------------

class AEKeyPair : public ::google::protobuf::Message {
 public:
  AEKeyPair();
  virtual ~AEKeyPair();
  
  AEKeyPair(const AEKeyPair& from);
  
  inline AEKeyPair& operator=(const AEKeyPair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AEKeyPair& default_instance();
  
  void Swap(AEKeyPair* other);
  
  // implements Message ----------------------------------------------
  
  AEKeyPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEKeyPair& from);
  void MergeFrom(const AEKeyPair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:aefilter.AEKeyPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AEKeyPair* default_instance_;
};
// -------------------------------------------------------------------

class AETextInfo : public ::google::protobuf::Message {
 public:
  AETextInfo();
  virtual ~AETextInfo();
  
  AETextInfo(const AETextInfo& from);
  
  inline AETextInfo& operator=(const AETextInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AETextInfo& default_instance();
  
  void Swap(AETextInfo* other);
  
  // implements Message ----------------------------------------------
  
  AETextInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AETextInfo& from);
  void MergeFrom(const AETextInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .aefilter.AEJustificationType justification = 1;
  inline bool has_justification() const;
  inline void clear_justification();
  static const int kJustificationFieldNumber = 1;
  inline aefilter::AEJustificationType justification() const;
  inline void set_justification(aefilter::AEJustificationType value);
  
  // required int32 fontSize = 2;
  inline bool has_fontsize() const;
  inline void clear_fontsize();
  static const int kFontSizeFieldNumber = 2;
  inline ::google::protobuf::int32 fontsize() const;
  inline void set_fontsize(::google::protobuf::int32 value);
  
  // required .aefilter.AEColor fontColor = 3;
  inline bool has_fontcolor() const;
  inline void clear_fontcolor();
  static const int kFontColorFieldNumber = 3;
  inline const ::aefilter::AEColor& fontcolor() const;
  inline ::aefilter::AEColor* mutable_fontcolor();
  inline ::aefilter::AEColor* release_fontcolor();
  
  // required string fontName = 4;
  inline bool has_fontname() const;
  inline void clear_fontname();
  static const int kFontNameFieldNumber = 4;
  inline const ::std::string& fontname() const;
  inline void set_fontname(const ::std::string& value);
  inline void set_fontname(const char* value);
  inline void set_fontname(const char* value, size_t size);
  inline ::std::string* mutable_fontname();
  inline ::std::string* release_fontname();
  
  // required bool isPointText = 5;
  inline bool has_ispointtext() const;
  inline void clear_ispointtext();
  static const int kIsPointTextFieldNumber = 5;
  inline bool ispointtext() const;
  inline void set_ispointtext(bool value);
  
  // optional int32 boundsWidth = 6;
  inline bool has_boundswidth() const;
  inline void clear_boundswidth();
  static const int kBoundsWidthFieldNumber = 6;
  inline ::google::protobuf::int32 boundswidth() const;
  inline void set_boundswidth(::google::protobuf::int32 value);
  
  // optional int32 boundsHeight = 7;
  inline bool has_boundsheight() const;
  inline void clear_boundsheight();
  static const int kBoundsHeightFieldNumber = 7;
  inline ::google::protobuf::int32 boundsheight() const;
  inline void set_boundsheight(::google::protobuf::int32 value);
  
  // optional bool isLabel = 8;
  inline bool has_islabel() const;
  inline void clear_islabel();
  static const int kIsLabelFieldNumber = 8;
  inline bool islabel() const;
  inline void set_islabel(bool value);
  
  // optional string text = 9;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 9;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // optional bool multiline = 10;
  inline bool has_multiline() const;
  inline void clear_multiline();
  static const int kMultilineFieldNumber = 10;
  inline bool multiline() const;
  inline void set_multiline(bool value);
  
  // optional bool ellipsis = 11;
  inline bool has_ellipsis() const;
  inline void clear_ellipsis();
  static const int kEllipsisFieldNumber = 11;
  inline bool ellipsis() const;
  inline void set_ellipsis(bool value);
  
  // optional uint32 leading = 12;
  inline bool has_leading() const;
  inline void clear_leading();
  static const int kLeadingFieldNumber = 12;
  inline ::google::protobuf::uint32 leading() const;
  inline void set_leading(::google::protobuf::uint32 value);
  
  // optional bool isAllCaps = 13;
  inline bool has_isallcaps() const;
  inline void clear_isallcaps();
  static const int kIsAllCapsFieldNumber = 13;
  inline bool isallcaps() const;
  inline void set_isallcaps(bool value);
  
  // @@protoc_insertion_point(class_scope:aefilter.AETextInfo)
 private:
  inline void set_has_justification();
  inline void clear_has_justification();
  inline void set_has_fontsize();
  inline void clear_has_fontsize();
  inline void set_has_fontcolor();
  inline void clear_has_fontcolor();
  inline void set_has_fontname();
  inline void clear_has_fontname();
  inline void set_has_ispointtext();
  inline void clear_has_ispointtext();
  inline void set_has_boundswidth();
  inline void clear_has_boundswidth();
  inline void set_has_boundsheight();
  inline void clear_has_boundsheight();
  inline void set_has_islabel();
  inline void clear_has_islabel();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_multiline();
  inline void clear_has_multiline();
  inline void set_has_ellipsis();
  inline void clear_has_ellipsis();
  inline void set_has_leading();
  inline void clear_has_leading();
  inline void set_has_isallcaps();
  inline void clear_has_isallcaps();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int justification_;
  ::google::protobuf::int32 fontsize_;
  ::aefilter::AEColor* fontcolor_;
  ::std::string* fontname_;
  ::google::protobuf::int32 boundswidth_;
  ::google::protobuf::int32 boundsheight_;
  ::std::string* text_;
  bool ispointtext_;
  bool islabel_;
  bool multiline_;
  bool ellipsis_;
  ::google::protobuf::uint32 leading_;
  bool isallcaps_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AETextInfo* default_instance_;
};
// -------------------------------------------------------------------

class AEMaskVertex : public ::google::protobuf::Message {
 public:
  AEMaskVertex();
  virtual ~AEMaskVertex();
  
  AEMaskVertex(const AEMaskVertex& from);
  
  inline AEMaskVertex& operator=(const AEMaskVertex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AEMaskVertex& default_instance();
  
  void Swap(AEMaskVertex* other);
  
  // implements Message ----------------------------------------------
  
  AEMaskVertex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEMaskVertex& from);
  void MergeFrom(const AEMaskVertex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float tan_in_x = 3;
  inline bool has_tan_in_x() const;
  inline void clear_tan_in_x();
  static const int kTanInXFieldNumber = 3;
  inline float tan_in_x() const;
  inline void set_tan_in_x(float value);
  
  // required float tan_in_y = 4;
  inline bool has_tan_in_y() const;
  inline void clear_tan_in_y();
  static const int kTanInYFieldNumber = 4;
  inline float tan_in_y() const;
  inline void set_tan_in_y(float value);
  
  // required float tan_out_x = 5;
  inline bool has_tan_out_x() const;
  inline void clear_tan_out_x();
  static const int kTanOutXFieldNumber = 5;
  inline float tan_out_x() const;
  inline void set_tan_out_x(float value);
  
  // required float tan_out_y = 6;
  inline bool has_tan_out_y() const;
  inline void clear_tan_out_y();
  static const int kTanOutYFieldNumber = 6;
  inline float tan_out_y() const;
  inline void set_tan_out_y(float value);
  
  // @@protoc_insertion_point(class_scope:aefilter.AEMaskVertex)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_tan_in_x();
  inline void clear_has_tan_in_x();
  inline void set_has_tan_in_y();
  inline void clear_has_tan_in_y();
  inline void set_has_tan_out_x();
  inline void clear_has_tan_out_x();
  inline void set_has_tan_out_y();
  inline void clear_has_tan_out_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float tan_in_x_;
  float tan_in_y_;
  float tan_out_x_;
  float tan_out_y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AEMaskVertex* default_instance_;
};
// -------------------------------------------------------------------

class AEMask : public ::google::protobuf::Message {
 public:
  AEMask();
  virtual ~AEMask();
  
  AEMask(const AEMask& from);
  
  inline AEMask& operator=(const AEMask& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AEMask& default_instance();
  
  void Swap(AEMask* other);
  
  // implements Message ----------------------------------------------
  
  AEMask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEMask& from);
  void MergeFrom(const AEMask& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool is_closed = 1;
  inline bool has_is_closed() const;
  inline void clear_is_closed();
  static const int kIsClosedFieldNumber = 1;
  inline bool is_closed() const;
  inline void set_is_closed(bool value);
  
  // required int32 mask_source_id = 2;
  inline bool has_mask_source_id() const;
  inline void clear_mask_source_id();
  static const int kMaskSourceIdFieldNumber = 2;
  inline ::google::protobuf::int32 mask_source_id() const;
  inline void set_mask_source_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:aefilter.AEMask)
 private:
  inline void set_has_is_closed();
  inline void clear_has_is_closed();
  inline void set_has_mask_source_id();
  inline void clear_has_mask_source_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool is_closed_;
  ::google::protobuf::int32 mask_source_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AEMask* default_instance_;
};
// -------------------------------------------------------------------

class AEEffectParam : public ::google::protobuf::Message {
 public:
  AEEffectParam();
  virtual ~AEEffectParam();
  
  AEEffectParam(const AEEffectParam& from);
  
  inline AEEffectParam& operator=(const AEEffectParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AEEffectParam& default_instance();
  
  void Swap(AEEffectParam* other);
  
  // implements Message ----------------------------------------------
  
  AEEffectParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEEffectParam& from);
  void MergeFrom(const AEEffectParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional float fvalue1 = 2;
  inline bool has_fvalue1() const;
  inline void clear_fvalue1();
  static const int kFvalue1FieldNumber = 2;
  inline float fvalue1() const;
  inline void set_fvalue1(float value);
  
  // optional float fvalue2 = 3;
  inline bool has_fvalue2() const;
  inline void clear_fvalue2();
  static const int kFvalue2FieldNumber = 3;
  inline float fvalue2() const;
  inline void set_fvalue2(float value);
  
  // optional float fvalue3 = 4;
  inline bool has_fvalue3() const;
  inline void clear_fvalue3();
  static const int kFvalue3FieldNumber = 4;
  inline float fvalue3() const;
  inline void set_fvalue3(float value);
  
  // @@protoc_insertion_point(class_scope:aefilter.AEEffectParam)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fvalue1();
  inline void clear_has_fvalue1();
  inline void set_has_fvalue2();
  inline void clear_has_fvalue2();
  inline void set_has_fvalue3();
  inline void clear_has_fvalue3();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  float fvalue1_;
  float fvalue2_;
  float fvalue3_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AEEffectParam* default_instance_;
};
// -------------------------------------------------------------------

class AEEffect : public ::google::protobuf::Message {
 public:
  AEEffect();
  virtual ~AEEffect();
  
  AEEffect(const AEEffect& from);
  
  inline AEEffect& operator=(const AEEffect& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AEEffect& default_instance();
  
  void Swap(AEEffect* other);
  
  // implements Message ----------------------------------------------
  
  AEEffect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEEffect& from);
  void MergeFrom(const AEEffect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .aefilter.AEEffectParam param = 1;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 1;
  inline const ::aefilter::AEEffectParam& param(int index) const;
  inline ::aefilter::AEEffectParam* mutable_param(int index);
  inline ::aefilter::AEEffectParam* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEEffectParam >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEEffectParam >*
      mutable_param();
  
  // @@protoc_insertion_point(class_scope:aefilter.AEEffect)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::aefilter::AEEffectParam > param_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AEEffect* default_instance_;
};
// -------------------------------------------------------------------

class AELayer : public ::google::protobuf::Message {
 public:
  AELayer();
  virtual ~AELayer();
  
  AELayer(const AELayer& from);
  
  inline AELayer& operator=(const AELayer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AELayer& default_instance();
  
  void Swap(AELayer* other);
  
  // implements Message ----------------------------------------------
  
  AELayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AELayer& from);
  void MergeFrom(const AELayer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required int32 sourceid = 4;
  inline bool has_sourceid() const;
  inline void clear_sourceid();
  static const int kSourceidFieldNumber = 4;
  inline ::google::protobuf::int32 sourceid() const;
  inline void set_sourceid(::google::protobuf::int32 value);
  
  // required .aefilter.AETransform transform = 5;
  inline bool has_transform() const;
  inline void clear_transform();
  static const int kTransformFieldNumber = 5;
  inline const ::aefilter::AETransform& transform() const;
  inline ::aefilter::AETransform* mutable_transform();
  inline ::aefilter::AETransform* release_transform();
  
  // required bool acceptsshadows = 6;
  inline bool has_acceptsshadows() const;
  inline void clear_acceptsshadows();
  static const int kAcceptsshadowsFieldNumber = 6;
  inline bool acceptsshadows() const;
  inline void set_acceptsshadows(bool value);
  
  // required bool acceptslights = 7;
  inline bool has_acceptslights() const;
  inline void clear_acceptslights();
  static const int kAcceptslightsFieldNumber = 7;
  inline bool acceptslights() const;
  inline void set_acceptslights(bool value);
  
  // required bool castsshadows = 8;
  inline bool has_castsshadows() const;
  inline void clear_castsshadows();
  static const int kCastsshadowsFieldNumber = 8;
  inline bool castsshadows() const;
  inline void set_castsshadows(bool value);
  
  // optional bool ishidden = 9;
  inline bool has_ishidden() const;
  inline void clear_ishidden();
  static const int kIshiddenFieldNumber = 9;
  inline bool ishidden() const;
  inline void set_ishidden(bool value);
  
  // optional .aefilter.AETextInfo textinfo = 10;
  inline bool has_textinfo() const;
  inline void clear_textinfo();
  static const int kTextinfoFieldNumber = 10;
  inline const ::aefilter::AETextInfo& textinfo() const;
  inline ::aefilter::AETextInfo* mutable_textinfo();
  inline ::aefilter::AETextInfo* release_textinfo();
  
  // optional int32 parentid = 11;
  inline bool has_parentid() const;
  inline void clear_parentid();
  static const int kParentidFieldNumber = 11;
  inline ::google::protobuf::int32 parentid() const;
  inline void set_parentid(::google::protobuf::int32 value);
  
  // repeated .aefilter.AEMask mask = 12;
  inline int mask_size() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 12;
  inline const ::aefilter::AEMask& mask(int index) const;
  inline ::aefilter::AEMask* mutable_mask(int index);
  inline ::aefilter::AEMask* add_mask();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEMask >&
      mask() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEMask >*
      mutable_mask();
  
  // repeated .aefilter.AEEffect effect = 13;
  inline int effect_size() const;
  inline void clear_effect();
  static const int kEffectFieldNumber = 13;
  inline const ::aefilter::AEEffect& effect(int index) const;
  inline ::aefilter::AEEffect* mutable_effect(int index);
  inline ::aefilter::AEEffect* add_effect();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEEffect >&
      effect() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEEffect >*
      mutable_effect();
  
  // optional string classname = 14;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 14;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  
  // repeated .aefilter.AEKeyPair properties = 15;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 15;
  inline const ::aefilter::AEKeyPair& properties(int index) const;
  inline ::aefilter::AEKeyPair* mutable_properties(int index);
  inline ::aefilter::AEKeyPair* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair >*
      mutable_properties();
  
  // @@protoc_insertion_point(class_scope:aefilter.AELayer)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_sourceid();
  inline void clear_has_sourceid();
  inline void set_has_transform();
  inline void clear_has_transform();
  inline void set_has_acceptsshadows();
  inline void clear_has_acceptsshadows();
  inline void set_has_acceptslights();
  inline void clear_has_acceptslights();
  inline void set_has_castsshadows();
  inline void clear_has_castsshadows();
  inline void set_has_ishidden();
  inline void clear_has_ishidden();
  inline void set_has_textinfo();
  inline void clear_has_textinfo();
  inline void set_has_parentid();
  inline void clear_has_parentid();
  inline void set_has_classname();
  inline void clear_has_classname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 sourceid_;
  ::aefilter::AETransform* transform_;
  bool acceptsshadows_;
  bool acceptslights_;
  bool castsshadows_;
  bool ishidden_;
  ::google::protobuf::int32 parentid_;
  ::aefilter::AETextInfo* textinfo_;
  ::google::protobuf::RepeatedPtrField< ::aefilter::AEMask > mask_;
  ::google::protobuf::RepeatedPtrField< ::aefilter::AEEffect > effect_;
  ::std::string* classname_;
  ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair > properties_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AELayer* default_instance_;
};
// -------------------------------------------------------------------

class AECamera : public ::google::protobuf::Message {
 public:
  AECamera();
  virtual ~AECamera();
  
  AECamera(const AECamera& from);
  
  inline AECamera& operator=(const AECamera& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AECamera& default_instance();
  
  void Swap(AECamera* other);
  
  // implements Message ----------------------------------------------
  
  AECamera* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AECamera& from);
  void MergeFrom(const AECamera& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required .aefilter.AETransform transform = 2;
  inline bool has_transform() const;
  inline void clear_transform();
  static const int kTransformFieldNumber = 2;
  inline const ::aefilter::AETransform& transform() const;
  inline ::aefilter::AETransform* mutable_transform();
  inline ::aefilter::AETransform* release_transform();
  
  // required float FOV = 3;
  inline bool has_fov() const;
  inline void clear_fov();
  static const int kFOVFieldNumber = 3;
  inline float fov() const;
  inline void set_fov(float value);
  
  // required int32 id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // repeated .aefilter.AEKeyPair properties = 5;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 5;
  inline const ::aefilter::AEKeyPair& properties(int index) const;
  inline ::aefilter::AEKeyPair* mutable_properties(int index);
  inline ::aefilter::AEKeyPair* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair >*
      mutable_properties();
  
  // optional int32 parentid = 11;
  inline bool has_parentid() const;
  inline void clear_parentid();
  static const int kParentidFieldNumber = 11;
  inline ::google::protobuf::int32 parentid() const;
  inline void set_parentid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:aefilter.AECamera)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_transform();
  inline void clear_has_transform();
  inline void set_has_fov();
  inline void clear_has_fov();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_parentid();
  inline void clear_has_parentid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::aefilter::AETransform* transform_;
  float fov_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair > properties_;
  ::google::protobuf::int32 parentid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AECamera* default_instance_;
};
// -------------------------------------------------------------------

class AELight : public ::google::protobuf::Message {
 public:
  AELight();
  virtual ~AELight();
  
  AELight(const AELight& from);
  
  inline AELight& operator=(const AELight& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AELight& default_instance();
  
  void Swap(AELight* other);
  
  // implements Message ----------------------------------------------
  
  AELight* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AELight& from);
  void MergeFrom(const AELight& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required .aefilter.AETransform transform = 2;
  inline bool has_transform() const;
  inline void clear_transform();
  static const int kTransformFieldNumber = 2;
  inline const ::aefilter::AETransform& transform() const;
  inline ::aefilter::AETransform* mutable_transform();
  inline ::aefilter::AETransform* release_transform();
  
  // required .aefilter.AELightType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline aefilter::AELightType type() const;
  inline void set_type(aefilter::AELightType value);
  
  // required .aefilter.AEVector color = 4;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 4;
  inline const ::aefilter::AEVector& color() const;
  inline ::aefilter::AEVector* mutable_color();
  inline ::aefilter::AEVector* release_color();
  
  // required bool castsshadows = 5;
  inline bool has_castsshadows() const;
  inline void clear_castsshadows();
  static const int kCastsshadowsFieldNumber = 5;
  inline bool castsshadows() const;
  inline void set_castsshadows(bool value);
  
  // required string parentname = 6;
  inline bool has_parentname() const;
  inline void clear_parentname();
  static const int kParentnameFieldNumber = 6;
  inline const ::std::string& parentname() const;
  inline void set_parentname(const ::std::string& value);
  inline void set_parentname(const char* value);
  inline void set_parentname(const char* value, size_t size);
  inline ::std::string* mutable_parentname();
  inline ::std::string* release_parentname();
  
  // optional float radius = 7;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 7;
  inline float radius() const;
  inline void set_radius(float value);
  
  // optional float falloff = 8;
  inline bool has_falloff() const;
  inline void clear_falloff();
  static const int kFalloffFieldNumber = 8;
  inline float falloff() const;
  inline void set_falloff(float value);
  
  // optional float spotexponent = 9;
  inline bool has_spotexponent() const;
  inline void clear_spotexponent();
  static const int kSpotexponentFieldNumber = 9;
  inline float spotexponent() const;
  inline void set_spotexponent(float value);
  
  // optional float spotcosine = 10;
  inline bool has_spotcosine() const;
  inline void clear_spotcosine();
  static const int kSpotcosineFieldNumber = 10;
  inline float spotcosine() const;
  inline void set_spotcosine(float value);
  
  // required int32 id = 11;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 11;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:aefilter.AELight)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_transform();
  inline void clear_has_transform();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_castsshadows();
  inline void clear_has_castsshadows();
  inline void set_has_parentname();
  inline void clear_has_parentname();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_falloff();
  inline void clear_has_falloff();
  inline void set_has_spotexponent();
  inline void clear_has_spotexponent();
  inline void set_has_spotcosine();
  inline void clear_has_spotcosine();
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::aefilter::AETransform* transform_;
  ::aefilter::AEVector* color_;
  int type_;
  bool castsshadows_;
  ::std::string* parentname_;
  float radius_;
  float falloff_;
  float spotexponent_;
  float spotcosine_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AELight* default_instance_;
};
// -------------------------------------------------------------------

class AETrackIdentifier : public ::google::protobuf::Message {
 public:
  AETrackIdentifier();
  virtual ~AETrackIdentifier();
  
  AETrackIdentifier(const AETrackIdentifier& from);
  
  inline AETrackIdentifier& operator=(const AETrackIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AETrackIdentifier& default_instance();
  
  void Swap(AETrackIdentifier* other);
  
  // implements Message ----------------------------------------------
  
  AETrackIdentifier* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AETrackIdentifier& from);
  void MergeFrom(const AETrackIdentifier& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 targetid = 1;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetidFieldNumber = 1;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);
  
  // required .aefilter.AEBinding binding = 2;
  inline bool has_binding() const;
  inline void clear_binding();
  static const int kBindingFieldNumber = 2;
  inline aefilter::AEBinding binding() const;
  inline void set_binding(aefilter::AEBinding value);
  
  // @@protoc_insertion_point(class_scope:aefilter.AETrackIdentifier)
 private:
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_binding();
  inline void clear_has_binding();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 targetid_;
  int binding_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AETrackIdentifier* default_instance_;
};
// -------------------------------------------------------------------

class AEComposition : public ::google::protobuf::Message {
 public:
  AEComposition();
  virtual ~AEComposition();
  
  AEComposition(const AEComposition& from);
  
  inline AEComposition& operator=(const AEComposition& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AEComposition& default_instance();
  
  void Swap(AEComposition* other);
  
  // implements Message ----------------------------------------------
  
  AEComposition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEComposition& from);
  void MergeFrom(const AEComposition& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required float width = 2;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline float width() const;
  inline void set_width(float value);
  
  // required float height = 3;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline float height() const;
  inline void set_height(float value);
  
  // required float defaultcameradistance = 4;
  inline bool has_defaultcameradistance() const;
  inline void clear_defaultcameradistance();
  static const int kDefaultcameradistanceFieldNumber = 4;
  inline float defaultcameradistance() const;
  inline void set_defaultcameradistance(float value);
  
  // repeated .aefilter.AECamera camera = 5;
  inline int camera_size() const;
  inline void clear_camera();
  static const int kCameraFieldNumber = 5;
  inline const ::aefilter::AECamera& camera(int index) const;
  inline ::aefilter::AECamera* mutable_camera(int index);
  inline ::aefilter::AECamera* add_camera();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AECamera >&
      camera() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AECamera >*
      mutable_camera();
  
  // repeated .aefilter.AELayer layer = 6;
  inline int layer_size() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 6;
  inline const ::aefilter::AELayer& layer(int index) const;
  inline ::aefilter::AELayer* mutable_layer(int index);
  inline ::aefilter::AELayer* add_layer();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AELayer >&
      layer() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AELayer >*
      mutable_layer();
  
  // repeated .aefilter.AELight lights = 7;
  inline int lights_size() const;
  inline void clear_lights();
  static const int kLightsFieldNumber = 7;
  inline const ::aefilter::AELight& lights(int index) const;
  inline ::aefilter::AELight* mutable_lights(int index);
  inline ::aefilter::AELight* add_lights();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AELight >&
      lights() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AELight >*
      mutable_lights();
  
  // optional string classname = 8;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 8;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  
  // optional .aefilter.AEColor bgcolor = 9;
  inline bool has_bgcolor() const;
  inline void clear_bgcolor();
  static const int kBgcolorFieldNumber = 9;
  inline const ::aefilter::AEColor& bgcolor() const;
  inline ::aefilter::AEColor* mutable_bgcolor();
  inline ::aefilter::AEColor* release_bgcolor();
  
  // optional string DEPRECATED_stylename = 10;
  inline bool has_deprecated_stylename() const;
  inline void clear_deprecated_stylename();
  static const int kDEPRECATEDStylenameFieldNumber = 10;
  inline const ::std::string& deprecated_stylename() const;
  inline void set_deprecated_stylename(const ::std::string& value);
  inline void set_deprecated_stylename(const char* value);
  inline void set_deprecated_stylename(const char* value, size_t size);
  inline ::std::string* mutable_deprecated_stylename();
  inline ::std::string* release_deprecated_stylename();
  
  // optional string packagename = 11;
  inline bool has_packagename() const;
  inline void clear_packagename();
  static const int kPackagenameFieldNumber = 11;
  inline const ::std::string& packagename() const;
  inline void set_packagename(const ::std::string& value);
  inline void set_packagename(const char* value);
  inline void set_packagename(const char* value, size_t size);
  inline ::std::string* mutable_packagename();
  inline ::std::string* release_packagename();
  
  // repeated .aefilter.AEKeyPair properties = 12;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 12;
  inline const ::aefilter::AEKeyPair& properties(int index) const;
  inline ::aefilter::AEKeyPair* mutable_properties(int index);
  inline ::aefilter::AEKeyPair* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair >*
      mutable_properties();
  
  // repeated string childtemplates = 13;
  inline int childtemplates_size() const;
  inline void clear_childtemplates();
  static const int kChildtemplatesFieldNumber = 13;
  inline const ::std::string& childtemplates(int index) const;
  inline ::std::string* mutable_childtemplates(int index);
  inline void set_childtemplates(int index, const ::std::string& value);
  inline void set_childtemplates(int index, const char* value);
  inline void set_childtemplates(int index, const char* value, size_t size);
  inline ::std::string* add_childtemplates();
  inline void add_childtemplates(const ::std::string& value);
  inline void add_childtemplates(const char* value);
  inline void add_childtemplates(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& childtemplates() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_childtemplates();
  
  // @@protoc_insertion_point(class_scope:aefilter.AEComposition)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_defaultcameradistance();
  inline void clear_has_defaultcameradistance();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_bgcolor();
  inline void clear_has_bgcolor();
  inline void set_has_deprecated_stylename();
  inline void clear_has_deprecated_stylename();
  inline void set_has_packagename();
  inline void clear_has_packagename();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  float width_;
  float height_;
  ::google::protobuf::RepeatedPtrField< ::aefilter::AECamera > camera_;
  ::google::protobuf::RepeatedPtrField< ::aefilter::AELayer > layer_;
  ::google::protobuf::RepeatedPtrField< ::aefilter::AELight > lights_;
  ::std::string* classname_;
  ::aefilter::AEColor* bgcolor_;
  ::std::string* deprecated_stylename_;
  ::std::string* packagename_;
  ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair > properties_;
  ::google::protobuf::RepeatedPtrField< ::std::string> childtemplates_;
  float defaultcameradistance_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AEComposition* default_instance_;
};
// -------------------------------------------------------------------

class AESource : public ::google::protobuf::Message {
 public:
  AESource();
  virtual ~AESource();
  
  AESource(const AESource& from);
  
  inline AESource& operator=(const AESource& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AESource& default_instance();
  
  void Swap(AESource* other);
  
  // implements Message ----------------------------------------------
  
  AESource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AESource& from);
  void MergeFrom(const AESource& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // required .aefilter.AESourceType srctype = 2;
  inline bool has_srctype() const;
  inline void clear_srctype();
  static const int kSrctypeFieldNumber = 2;
  inline aefilter::AESourceType srctype() const;
  inline void set_srctype(aefilter::AESourceType value);
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional .aefilter.AEComposition comp = 4;
  inline bool has_comp() const;
  inline void clear_comp();
  static const int kCompFieldNumber = 4;
  inline const ::aefilter::AEComposition& comp() const;
  inline ::aefilter::AEComposition* mutable_comp();
  inline ::aefilter::AEComposition* release_comp();
  
  // optional .aefilter.AEColor color = 5;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 5;
  inline const ::aefilter::AEColor& color() const;
  inline ::aefilter::AEColor* mutable_color();
  inline ::aefilter::AEColor* release_color();
  
  // optional int32 width = 6;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 6;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // optional int32 height = 7;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 7;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // optional int32 numberOfFrames = 9;
  inline bool has_numberofframes() const;
  inline void clear_numberofframes();
  static const int kNumberOfFramesFieldNumber = 9;
  inline ::google::protobuf::int32 numberofframes() const;
  inline void set_numberofframes(::google::protobuf::int32 value);
  
  // optional int32 fps = 10;
  inline bool has_fps() const;
  inline void clear_fps();
  static const int kFpsFieldNumber = 10;
  inline ::google::protobuf::int32 fps() const;
  inline void set_fps(::google::protobuf::int32 value);
  
  // optional int32 loops = 11;
  inline bool has_loops() const;
  inline void clear_loops();
  static const int kLoopsFieldNumber = 11;
  inline ::google::protobuf::int32 loops() const;
  inline void set_loops(::google::protobuf::int32 value);
  
  // optional bool copy_source = 12;
  inline bool has_copy_source() const;
  inline void clear_copy_source();
  static const int kCopySourceFieldNumber = 12;
  inline bool copy_source() const;
  inline void set_copy_source(bool value);
  
  // optional string file_name = 13;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 13;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  
  // @@protoc_insertion_point(class_scope:aefilter.AESource)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_srctype();
  inline void clear_has_srctype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_comp();
  inline void clear_has_comp();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_numberofframes();
  inline void clear_has_numberofframes();
  inline void set_has_fps();
  inline void clear_has_fps();
  inline void set_has_loops();
  inline void clear_has_loops();
  inline void set_has_copy_source();
  inline void clear_has_copy_source();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 uid_;
  int srctype_;
  ::std::string* name_;
  ::aefilter::AEComposition* comp_;
  ::aefilter::AEColor* color_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 numberofframes_;
  ::google::protobuf::int32 fps_;
  ::google::protobuf::int32 loops_;
  bool copy_source_;
  ::std::string* file_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AESource* default_instance_;
};
// -------------------------------------------------------------------

class AELayout : public ::google::protobuf::Message {
 public:
  AELayout();
  virtual ~AELayout();
  
  AELayout(const AELayout& from);
  
  inline AELayout& operator=(const AELayout& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AELayout& default_instance();
  
  void Swap(AELayout* other);
  
  // implements Message ----------------------------------------------
  
  AELayout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AELayout& from);
  void MergeFrom(const AELayout& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .aefilter.AEComposition activecomp = 1;
  inline bool has_activecomp() const;
  inline void clear_activecomp();
  static const int kActivecompFieldNumber = 1;
  inline const ::aefilter::AEComposition& activecomp() const;
  inline ::aefilter::AEComposition* mutable_activecomp();
  inline ::aefilter::AEComposition* release_activecomp();
  
  // repeated .aefilter.AESource sources = 2;
  inline int sources_size() const;
  inline void clear_sources();
  static const int kSourcesFieldNumber = 2;
  inline const ::aefilter::AESource& sources(int index) const;
  inline ::aefilter::AESource* mutable_sources(int index);
  inline ::aefilter::AESource* add_sources();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AESource >&
      sources() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AESource >*
      mutable_sources();
  
  // @@protoc_insertion_point(class_scope:aefilter.AELayout)
 private:
  inline void set_has_activecomp();
  inline void clear_has_activecomp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::aefilter::AEComposition* activecomp_;
  ::google::protobuf::RepeatedPtrField< ::aefilter::AESource > sources_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AELayout* default_instance_;
};
// -------------------------------------------------------------------

class AEKeytimeEase : public ::google::protobuf::Message {
 public:
  AEKeytimeEase();
  virtual ~AEKeytimeEase();
  
  AEKeytimeEase(const AEKeytimeEase& from);
  
  inline AEKeytimeEase& operator=(const AEKeytimeEase& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AEKeytimeEase& default_instance();
  
  void Swap(AEKeytimeEase* other);
  
  // implements Message ----------------------------------------------
  
  AEKeytimeEase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEKeytimeEase& from);
  void MergeFrom(const AEKeytimeEase& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float speedIn = 1;
  inline bool has_speedin() const;
  inline void clear_speedin();
  static const int kSpeedInFieldNumber = 1;
  inline float speedin() const;
  inline void set_speedin(float value);
  
  // required float influenceIn = 2;
  inline bool has_influencein() const;
  inline void clear_influencein();
  static const int kInfluenceInFieldNumber = 2;
  inline float influencein() const;
  inline void set_influencein(float value);
  
  // required float speedOut = 3;
  inline bool has_speedout() const;
  inline void clear_speedout();
  static const int kSpeedOutFieldNumber = 3;
  inline float speedout() const;
  inline void set_speedout(float value);
  
  // required float influenceOut = 4;
  inline bool has_influenceout() const;
  inline void clear_influenceout();
  static const int kInfluenceOutFieldNumber = 4;
  inline float influenceout() const;
  inline void set_influenceout(float value);
  
  // @@protoc_insertion_point(class_scope:aefilter.AEKeytimeEase)
 private:
  inline void set_has_speedin();
  inline void clear_has_speedin();
  inline void set_has_influencein();
  inline void clear_has_influencein();
  inline void set_has_speedout();
  inline void clear_has_speedout();
  inline void set_has_influenceout();
  inline void clear_has_influenceout();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float speedin_;
  float influencein_;
  float speedout_;
  float influenceout_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AEKeytimeEase* default_instance_;
};
// -------------------------------------------------------------------

class AEKeytime : public ::google::protobuf::Message {
 public:
  AEKeytime();
  virtual ~AEKeytime();
  
  AEKeytime(const AEKeytime& from);
  
  inline AEKeytime& operator=(const AEKeytime& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AEKeytime& default_instance();
  
  void Swap(AEKeytime* other);
  
  // implements Message ----------------------------------------------
  
  AEKeytime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEKeytime& from);
  void MergeFrom(const AEKeytime& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .aefilter.AEDataType datatype = 1;
  inline bool has_datatype() const;
  inline void clear_datatype();
  static const int kDatatypeFieldNumber = 1;
  inline aefilter::AEDataType datatype() const;
  inline void set_datatype(aefilter::AEDataType value);
  
  // required float timeOffset = 2;
  inline bool has_timeoffset() const;
  inline void clear_timeoffset();
  static const int kTimeOffsetFieldNumber = 2;
  inline float timeoffset() const;
  inline void set_timeoffset(float value);
  
  // required .aefilter.AEIType inttype = 3;
  inline bool has_inttype() const;
  inline void clear_inttype();
  static const int kInttypeFieldNumber = 3;
  inline aefilter::AEIType inttype() const;
  inline void set_inttype(aefilter::AEIType value);
  
  // optional float obsoleteSpeedIn = 5;
  inline bool has_obsoletespeedin() const;
  inline void clear_obsoletespeedin();
  static const int kObsoleteSpeedInFieldNumber = 5;
  inline float obsoletespeedin() const;
  inline void set_obsoletespeedin(float value);
  
  // optional float obsoleteInfluenceIn = 6;
  inline bool has_obsoleteinfluencein() const;
  inline void clear_obsoleteinfluencein();
  static const int kObsoleteInfluenceInFieldNumber = 6;
  inline float obsoleteinfluencein() const;
  inline void set_obsoleteinfluencein(float value);
  
  // optional float obsoleteSpeedOut = 7;
  inline bool has_obsoletespeedout() const;
  inline void clear_obsoletespeedout();
  static const int kObsoleteSpeedOutFieldNumber = 7;
  inline float obsoletespeedout() const;
  inline void set_obsoletespeedout(float value);
  
  // optional float obsoleteInfluenceOut = 8;
  inline bool has_obsoleteinfluenceout() const;
  inline void clear_obsoleteinfluenceout();
  static const int kObsoleteInfluenceOutFieldNumber = 8;
  inline float obsoleteinfluenceout() const;
  inline void set_obsoleteinfluenceout(float value);
  
  // optional float sInTangentX = 9;
  inline bool has_sintangentx() const;
  inline void clear_sintangentx();
  static const int kSInTangentXFieldNumber = 9;
  inline float sintangentx() const;
  inline void set_sintangentx(float value);
  
  // optional float sInTangentY = 10;
  inline bool has_sintangenty() const;
  inline void clear_sintangenty();
  static const int kSInTangentYFieldNumber = 10;
  inline float sintangenty() const;
  inline void set_sintangenty(float value);
  
  // optional float sInTangentZ = 11;
  inline bool has_sintangentz() const;
  inline void clear_sintangentz();
  static const int kSInTangentZFieldNumber = 11;
  inline float sintangentz() const;
  inline void set_sintangentz(float value);
  
  // optional float sOutTangentX = 12;
  inline bool has_souttangentx() const;
  inline void clear_souttangentx();
  static const int kSOutTangentXFieldNumber = 12;
  inline float souttangentx() const;
  inline void set_souttangentx(float value);
  
  // optional float sOutTangentY = 13;
  inline bool has_souttangenty() const;
  inline void clear_souttangenty();
  static const int kSOutTangentYFieldNumber = 13;
  inline float souttangenty() const;
  inline void set_souttangenty(float value);
  
  // optional float sOutTangentZ = 14;
  inline bool has_souttangentz() const;
  inline void clear_souttangentz();
  static const int kSOutTangentZFieldNumber = 14;
  inline float souttangentz() const;
  inline void set_souttangentz(float value);
  
  // optional float fvalue1 = 15;
  inline bool has_fvalue1() const;
  inline void clear_fvalue1();
  static const int kFvalue1FieldNumber = 15;
  inline float fvalue1() const;
  inline void set_fvalue1(float value);
  
  // optional float fvalue2 = 16;
  inline bool has_fvalue2() const;
  inline void clear_fvalue2();
  static const int kFvalue2FieldNumber = 16;
  inline float fvalue2() const;
  inline void set_fvalue2(float value);
  
  // optional float fvalue3 = 17;
  inline bool has_fvalue3() const;
  inline void clear_fvalue3();
  static const int kFvalue3FieldNumber = 17;
  inline float fvalue3() const;
  inline void set_fvalue3(float value);
  
  // optional int32 ivalue1 = 18;
  inline bool has_ivalue1() const;
  inline void clear_ivalue1();
  static const int kIvalue1FieldNumber = 18;
  inline ::google::protobuf::int32 ivalue1() const;
  inline void set_ivalue1(::google::protobuf::int32 value);
  
  // repeated .aefilter.AEKeytimeEase easeValues = 19;
  inline int easevalues_size() const;
  inline void clear_easevalues();
  static const int kEaseValuesFieldNumber = 19;
  inline const ::aefilter::AEKeytimeEase& easevalues(int index) const;
  inline ::aefilter::AEKeytimeEase* mutable_easevalues(int index);
  inline ::aefilter::AEKeytimeEase* add_easevalues();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeytimeEase >&
      easevalues() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeytimeEase >*
      mutable_easevalues();
  
  // optional bool isCookedKeytime = 20;
  inline bool has_iscookedkeytime() const;
  inline void clear_iscookedkeytime();
  static const int kIsCookedKeytimeFieldNumber = 20;
  inline bool iscookedkeytime() const;
  inline void set_iscookedkeytime(bool value);
  
  // @@protoc_insertion_point(class_scope:aefilter.AEKeytime)
 private:
  inline void set_has_datatype();
  inline void clear_has_datatype();
  inline void set_has_timeoffset();
  inline void clear_has_timeoffset();
  inline void set_has_inttype();
  inline void clear_has_inttype();
  inline void set_has_obsoletespeedin();
  inline void clear_has_obsoletespeedin();
  inline void set_has_obsoleteinfluencein();
  inline void clear_has_obsoleteinfluencein();
  inline void set_has_obsoletespeedout();
  inline void clear_has_obsoletespeedout();
  inline void set_has_obsoleteinfluenceout();
  inline void clear_has_obsoleteinfluenceout();
  inline void set_has_sintangentx();
  inline void clear_has_sintangentx();
  inline void set_has_sintangenty();
  inline void clear_has_sintangenty();
  inline void set_has_sintangentz();
  inline void clear_has_sintangentz();
  inline void set_has_souttangentx();
  inline void clear_has_souttangentx();
  inline void set_has_souttangenty();
  inline void clear_has_souttangenty();
  inline void set_has_souttangentz();
  inline void clear_has_souttangentz();
  inline void set_has_fvalue1();
  inline void clear_has_fvalue1();
  inline void set_has_fvalue2();
  inline void clear_has_fvalue2();
  inline void set_has_fvalue3();
  inline void clear_has_fvalue3();
  inline void set_has_ivalue1();
  inline void clear_has_ivalue1();
  inline void set_has_iscookedkeytime();
  inline void clear_has_iscookedkeytime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int datatype_;
  float timeoffset_;
  int inttype_;
  float obsoletespeedin_;
  float obsoleteinfluencein_;
  float obsoletespeedout_;
  float obsoleteinfluenceout_;
  float sintangentx_;
  float sintangenty_;
  float sintangentz_;
  float souttangentx_;
  float souttangenty_;
  float souttangentz_;
  float fvalue1_;
  float fvalue2_;
  float fvalue3_;
  ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeytimeEase > easevalues_;
  ::google::protobuf::int32 ivalue1_;
  bool iscookedkeytime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AEKeytime* default_instance_;
};
// -------------------------------------------------------------------

class AETrack : public ::google::protobuf::Message {
 public:
  AETrack();
  virtual ~AETrack();
  
  AETrack(const AETrack& from);
  
  inline AETrack& operator=(const AETrack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AETrack& default_instance();
  
  void Swap(AETrack* other);
  
  // implements Message ----------------------------------------------
  
  AETrack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AETrack& from);
  void MergeFrom(const AETrack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .aefilter.AEBinding binding = 1;
  inline bool has_binding() const;
  inline void clear_binding();
  static const int kBindingFieldNumber = 1;
  inline aefilter::AEBinding binding() const;
  inline void set_binding(aefilter::AEBinding value);
  
  // required int32 targetid = 2;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetidFieldNumber = 2;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);
  
  // required string targetname = 3;
  inline bool has_targetname() const;
  inline void clear_targetname();
  static const int kTargetnameFieldNumber = 3;
  inline const ::std::string& targetname() const;
  inline void set_targetname(const ::std::string& value);
  inline void set_targetname(const char* value);
  inline void set_targetname(const char* value, size_t size);
  inline ::std::string* mutable_targetname();
  inline ::std::string* release_targetname();
  
  // repeated .aefilter.AEKeytime keytimes = 4;
  inline int keytimes_size() const;
  inline void clear_keytimes();
  static const int kKeytimesFieldNumber = 4;
  inline const ::aefilter::AEKeytime& keytimes(int index) const;
  inline ::aefilter::AEKeytime* mutable_keytimes(int index);
  inline ::aefilter::AEKeytime* add_keytimes();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeytime >&
      keytimes() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeytime >*
      mutable_keytimes();
  
  // optional string trackName = 5;
  inline bool has_trackname() const;
  inline void clear_trackname();
  static const int kTrackNameFieldNumber = 5;
  inline const ::std::string& trackname() const;
  inline void set_trackname(const ::std::string& value);
  inline void set_trackname(const char* value);
  inline void set_trackname(const char* value, size_t size);
  inline ::std::string* mutable_trackname();
  inline ::std::string* release_trackname();
  
  // @@protoc_insertion_point(class_scope:aefilter.AETrack)
 private:
  inline void set_has_binding();
  inline void clear_has_binding();
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_targetname();
  inline void clear_has_targetname();
  inline void set_has_trackname();
  inline void clear_has_trackname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int binding_;
  ::google::protobuf::int32 targetid_;
  ::std::string* targetname_;
  ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeytime > keytimes_;
  ::std::string* trackname_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AETrack* default_instance_;
};
// -------------------------------------------------------------------

class AEMarker : public ::google::protobuf::Message {
 public:
  AEMarker();
  virtual ~AEMarker();
  
  AEMarker(const AEMarker& from);
  
  inline AEMarker& operator=(const AEMarker& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AEMarker& default_instance();
  
  void Swap(AEMarker* other);
  
  // implements Message ----------------------------------------------
  
  AEMarker* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEMarker& from);
  void MergeFrom(const AEMarker& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float starttime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 1;
  inline float starttime() const;
  inline void set_starttime(float value);
  
  // required float duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline float duration() const;
  inline void set_duration(float value);
  
  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .aefilter.AETrackIdentifier tracksSelection = 4;
  inline int tracksselection_size() const;
  inline void clear_tracksselection();
  static const int kTracksSelectionFieldNumber = 4;
  inline const ::aefilter::AETrackIdentifier& tracksselection(int index) const;
  inline ::aefilter::AETrackIdentifier* mutable_tracksselection(int index);
  inline ::aefilter::AETrackIdentifier* add_tracksselection();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AETrackIdentifier >&
      tracksselection() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AETrackIdentifier >*
      mutable_tracksselection();
  
  // optional bool alltracks = 5;
  inline bool has_alltracks() const;
  inline void clear_alltracks();
  static const int kAlltracksFieldNumber = 5;
  inline bool alltracks() const;
  inline void set_alltracks(bool value);
  
  // optional int32 id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional bool looping = 7;
  inline bool has_looping() const;
  inline void clear_looping();
  static const int kLoopingFieldNumber = 7;
  inline bool looping() const;
  inline void set_looping(bool value);
  
  // @@protoc_insertion_point(class_scope:aefilter.AEMarker)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_alltracks();
  inline void clear_has_alltracks();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_looping();
  inline void clear_has_looping();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float starttime_;
  float duration_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::aefilter::AETrackIdentifier > tracksselection_;
  ::google::protobuf::int32 id_;
  bool alltracks_;
  bool looping_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AEMarker* default_instance_;
};
// -------------------------------------------------------------------

class AETimeline : public ::google::protobuf::Message {
 public:
  AETimeline();
  virtual ~AETimeline();
  
  AETimeline(const AETimeline& from);
  
  inline AETimeline& operator=(const AETimeline& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AETimeline& default_instance();
  
  void Swap(AETimeline* other);
  
  // implements Message ----------------------------------------------
  
  AETimeline* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AETimeline& from);
  void MergeFrom(const AETimeline& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .aefilter.AETrack tracks = 1;
  inline int tracks_size() const;
  inline void clear_tracks();
  static const int kTracksFieldNumber = 1;
  inline const ::aefilter::AETrack& tracks(int index) const;
  inline ::aefilter::AETrack* mutable_tracks(int index);
  inline ::aefilter::AETrack* add_tracks();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AETrack >&
      tracks() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AETrack >*
      mutable_tracks();
  
  // repeated .aefilter.AEMarker markers = 2;
  inline int markers_size() const;
  inline void clear_markers();
  static const int kMarkersFieldNumber = 2;
  inline const ::aefilter::AEMarker& markers(int index) const;
  inline ::aefilter::AEMarker* mutable_markers(int index);
  inline ::aefilter::AEMarker* add_markers();
  inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEMarker >&
      markers() const;
  inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEMarker >*
      mutable_markers();
  
  // @@protoc_insertion_point(class_scope:aefilter.AETimeline)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::aefilter::AETrack > tracks_;
  ::google::protobuf::RepeatedPtrField< ::aefilter::AEMarker > markers_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_AEFilter_2eproto();
  friend void protobuf_AssignDesc_AEFilter_2eproto();
  friend void protobuf_ShutdownFile_AEFilter_2eproto();
  
  void InitAsDefaultInstance();
  static AETimeline* default_instance_;
};
// ===================================================================


// ===================================================================

// AEVector

// required float x = 1;
inline bool AEVector::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEVector::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEVector::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEVector::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float AEVector::x() const {
  return x_;
}
inline void AEVector::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool AEVector::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEVector::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEVector::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEVector::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float AEVector::y() const {
  return y_;
}
inline void AEVector::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool AEVector::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AEVector::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AEVector::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AEVector::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float AEVector::z() const {
  return z_;
}
inline void AEVector::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// AEColor

// required double alpha = 1;
inline bool AEColor::has_alpha() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEColor::set_has_alpha() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEColor::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEColor::clear_alpha() {
  alpha_ = 0;
  clear_has_alpha();
}
inline double AEColor::alpha() const {
  return alpha_;
}
inline void AEColor::set_alpha(double value) {
  set_has_alpha();
  alpha_ = value;
}

// required double red = 2;
inline bool AEColor::has_red() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEColor::set_has_red() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEColor::clear_has_red() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEColor::clear_red() {
  red_ = 0;
  clear_has_red();
}
inline double AEColor::red() const {
  return red_;
}
inline void AEColor::set_red(double value) {
  set_has_red();
  red_ = value;
}

// required double green = 3;
inline bool AEColor::has_green() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AEColor::set_has_green() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AEColor::clear_has_green() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AEColor::clear_green() {
  green_ = 0;
  clear_has_green();
}
inline double AEColor::green() const {
  return green_;
}
inline void AEColor::set_green(double value) {
  set_has_green();
  green_ = value;
}

// required double blue = 4;
inline bool AEColor::has_blue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AEColor::set_has_blue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AEColor::clear_has_blue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AEColor::clear_blue() {
  blue_ = 0;
  clear_has_blue();
}
inline double AEColor::blue() const {
  return blue_;
}
inline void AEColor::set_blue(double value) {
  set_has_blue();
  blue_ = value;
}

// -------------------------------------------------------------------

// AETransform

// required .aefilter.AEVector anchorPoint = 1;
inline bool AETransform::has_anchorpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AETransform::set_has_anchorpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AETransform::clear_has_anchorpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AETransform::clear_anchorpoint() {
  if (anchorpoint_ != NULL) anchorpoint_->::aefilter::AEVector::Clear();
  clear_has_anchorpoint();
}
inline const ::aefilter::AEVector& AETransform::anchorpoint() const {
  return anchorpoint_ != NULL ? *anchorpoint_ : *default_instance_->anchorpoint_;
}
inline ::aefilter::AEVector* AETransform::mutable_anchorpoint() {
  set_has_anchorpoint();
  if (anchorpoint_ == NULL) anchorpoint_ = new ::aefilter::AEVector;
  return anchorpoint_;
}
inline ::aefilter::AEVector* AETransform::release_anchorpoint() {
  clear_has_anchorpoint();
  ::aefilter::AEVector* temp = anchorpoint_;
  anchorpoint_ = NULL;
  return temp;
}

// required .aefilter.AEVector scale = 2;
inline bool AETransform::has_scale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AETransform::set_has_scale() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AETransform::clear_has_scale() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AETransform::clear_scale() {
  if (scale_ != NULL) scale_->::aefilter::AEVector::Clear();
  clear_has_scale();
}
inline const ::aefilter::AEVector& AETransform::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::aefilter::AEVector* AETransform::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::aefilter::AEVector;
  return scale_;
}
inline ::aefilter::AEVector* AETransform::release_scale() {
  clear_has_scale();
  ::aefilter::AEVector* temp = scale_;
  scale_ = NULL;
  return temp;
}

// required .aefilter.AEVector position = 3;
inline bool AETransform::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AETransform::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AETransform::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AETransform::clear_position() {
  if (position_ != NULL) position_->::aefilter::AEVector::Clear();
  clear_has_position();
}
inline const ::aefilter::AEVector& AETransform::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::aefilter::AEVector* AETransform::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::aefilter::AEVector;
  return position_;
}
inline ::aefilter::AEVector* AETransform::release_position() {
  clear_has_position();
  ::aefilter::AEVector* temp = position_;
  position_ = NULL;
  return temp;
}

// required .aefilter.AEVector orientation = 4;
inline bool AETransform::has_orientation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AETransform::set_has_orientation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AETransform::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AETransform::clear_orientation() {
  if (orientation_ != NULL) orientation_->::aefilter::AEVector::Clear();
  clear_has_orientation();
}
inline const ::aefilter::AEVector& AETransform::orientation() const {
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::aefilter::AEVector* AETransform::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) orientation_ = new ::aefilter::AEVector;
  return orientation_;
}
inline ::aefilter::AEVector* AETransform::release_orientation() {
  clear_has_orientation();
  ::aefilter::AEVector* temp = orientation_;
  orientation_ = NULL;
  return temp;
}

// required float rotationX = 5;
inline bool AETransform::has_rotationx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AETransform::set_has_rotationx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AETransform::clear_has_rotationx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AETransform::clear_rotationx() {
  rotationx_ = 0;
  clear_has_rotationx();
}
inline float AETransform::rotationx() const {
  return rotationx_;
}
inline void AETransform::set_rotationx(float value) {
  set_has_rotationx();
  rotationx_ = value;
}

// required float rotationY = 6;
inline bool AETransform::has_rotationy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AETransform::set_has_rotationy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AETransform::clear_has_rotationy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AETransform::clear_rotationy() {
  rotationy_ = 0;
  clear_has_rotationy();
}
inline float AETransform::rotationy() const {
  return rotationy_;
}
inline void AETransform::set_rotationy(float value) {
  set_has_rotationy();
  rotationy_ = value;
}

// required float rotationZ = 7;
inline bool AETransform::has_rotationz() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AETransform::set_has_rotationz() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AETransform::clear_has_rotationz() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AETransform::clear_rotationz() {
  rotationz_ = 0;
  clear_has_rotationz();
}
inline float AETransform::rotationz() const {
  return rotationz_;
}
inline void AETransform::set_rotationz(float value) {
  set_has_rotationz();
  rotationz_ = value;
}

// required float opacity = 8;
inline bool AETransform::has_opacity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AETransform::set_has_opacity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AETransform::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AETransform::clear_opacity() {
  opacity_ = 0;
  clear_has_opacity();
}
inline float AETransform::opacity() const {
  return opacity_;
}
inline void AETransform::set_opacity(float value) {
  set_has_opacity();
  opacity_ = value;
}

// -------------------------------------------------------------------

// AEKeyPair

// required string key = 1;
inline bool AEKeyPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEKeyPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEKeyPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEKeyPair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& AEKeyPair::key() const {
  return *key_;
}
inline void AEKeyPair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void AEKeyPair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void AEKeyPair::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AEKeyPair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* AEKeyPair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string value = 2;
inline bool AEKeyPair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEKeyPair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEKeyPair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEKeyPair::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& AEKeyPair::value() const {
  return *value_;
}
inline void AEKeyPair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void AEKeyPair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void AEKeyPair::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AEKeyPair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* AEKeyPair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AETextInfo

// required .aefilter.AEJustificationType justification = 1;
inline bool AETextInfo::has_justification() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AETextInfo::set_has_justification() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AETextInfo::clear_has_justification() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AETextInfo::clear_justification() {
  justification_ = -1;
  clear_has_justification();
}
inline aefilter::AEJustificationType AETextInfo::justification() const {
  return static_cast< aefilter::AEJustificationType >(justification_);
}
inline void AETextInfo::set_justification(aefilter::AEJustificationType value) {
  GOOGLE_DCHECK(aefilter::AEJustificationType_IsValid(value));
  set_has_justification();
  justification_ = value;
}

// required int32 fontSize = 2;
inline bool AETextInfo::has_fontsize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AETextInfo::set_has_fontsize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AETextInfo::clear_has_fontsize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AETextInfo::clear_fontsize() {
  fontsize_ = 0;
  clear_has_fontsize();
}
inline ::google::protobuf::int32 AETextInfo::fontsize() const {
  return fontsize_;
}
inline void AETextInfo::set_fontsize(::google::protobuf::int32 value) {
  set_has_fontsize();
  fontsize_ = value;
}

// required .aefilter.AEColor fontColor = 3;
inline bool AETextInfo::has_fontcolor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AETextInfo::set_has_fontcolor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AETextInfo::clear_has_fontcolor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AETextInfo::clear_fontcolor() {
  if (fontcolor_ != NULL) fontcolor_->::aefilter::AEColor::Clear();
  clear_has_fontcolor();
}
inline const ::aefilter::AEColor& AETextInfo::fontcolor() const {
  return fontcolor_ != NULL ? *fontcolor_ : *default_instance_->fontcolor_;
}
inline ::aefilter::AEColor* AETextInfo::mutable_fontcolor() {
  set_has_fontcolor();
  if (fontcolor_ == NULL) fontcolor_ = new ::aefilter::AEColor;
  return fontcolor_;
}
inline ::aefilter::AEColor* AETextInfo::release_fontcolor() {
  clear_has_fontcolor();
  ::aefilter::AEColor* temp = fontcolor_;
  fontcolor_ = NULL;
  return temp;
}

// required string fontName = 4;
inline bool AETextInfo::has_fontname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AETextInfo::set_has_fontname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AETextInfo::clear_has_fontname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AETextInfo::clear_fontname() {
  if (fontname_ != &::google::protobuf::internal::kEmptyString) {
    fontname_->clear();
  }
  clear_has_fontname();
}
inline const ::std::string& AETextInfo::fontname() const {
  return *fontname_;
}
inline void AETextInfo::set_fontname(const ::std::string& value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
}
inline void AETextInfo::set_fontname(const char* value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
}
inline void AETextInfo::set_fontname(const char* value, size_t size) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AETextInfo::mutable_fontname() {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  return fontname_;
}
inline ::std::string* AETextInfo::release_fontname() {
  clear_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fontname_;
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool isPointText = 5;
inline bool AETextInfo::has_ispointtext() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AETextInfo::set_has_ispointtext() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AETextInfo::clear_has_ispointtext() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AETextInfo::clear_ispointtext() {
  ispointtext_ = false;
  clear_has_ispointtext();
}
inline bool AETextInfo::ispointtext() const {
  return ispointtext_;
}
inline void AETextInfo::set_ispointtext(bool value) {
  set_has_ispointtext();
  ispointtext_ = value;
}

// optional int32 boundsWidth = 6;
inline bool AETextInfo::has_boundswidth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AETextInfo::set_has_boundswidth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AETextInfo::clear_has_boundswidth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AETextInfo::clear_boundswidth() {
  boundswidth_ = 0;
  clear_has_boundswidth();
}
inline ::google::protobuf::int32 AETextInfo::boundswidth() const {
  return boundswidth_;
}
inline void AETextInfo::set_boundswidth(::google::protobuf::int32 value) {
  set_has_boundswidth();
  boundswidth_ = value;
}

// optional int32 boundsHeight = 7;
inline bool AETextInfo::has_boundsheight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AETextInfo::set_has_boundsheight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AETextInfo::clear_has_boundsheight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AETextInfo::clear_boundsheight() {
  boundsheight_ = 0;
  clear_has_boundsheight();
}
inline ::google::protobuf::int32 AETextInfo::boundsheight() const {
  return boundsheight_;
}
inline void AETextInfo::set_boundsheight(::google::protobuf::int32 value) {
  set_has_boundsheight();
  boundsheight_ = value;
}

// optional bool isLabel = 8;
inline bool AETextInfo::has_islabel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AETextInfo::set_has_islabel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AETextInfo::clear_has_islabel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AETextInfo::clear_islabel() {
  islabel_ = false;
  clear_has_islabel();
}
inline bool AETextInfo::islabel() const {
  return islabel_;
}
inline void AETextInfo::set_islabel(bool value) {
  set_has_islabel();
  islabel_ = value;
}

// optional string text = 9;
inline bool AETextInfo::has_text() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AETextInfo::set_has_text() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AETextInfo::clear_has_text() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AETextInfo::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& AETextInfo::text() const {
  return *text_;
}
inline void AETextInfo::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void AETextInfo::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void AETextInfo::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AETextInfo::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* AETextInfo::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool multiline = 10;
inline bool AETextInfo::has_multiline() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AETextInfo::set_has_multiline() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AETextInfo::clear_has_multiline() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AETextInfo::clear_multiline() {
  multiline_ = false;
  clear_has_multiline();
}
inline bool AETextInfo::multiline() const {
  return multiline_;
}
inline void AETextInfo::set_multiline(bool value) {
  set_has_multiline();
  multiline_ = value;
}

// optional bool ellipsis = 11;
inline bool AETextInfo::has_ellipsis() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AETextInfo::set_has_ellipsis() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AETextInfo::clear_has_ellipsis() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AETextInfo::clear_ellipsis() {
  ellipsis_ = false;
  clear_has_ellipsis();
}
inline bool AETextInfo::ellipsis() const {
  return ellipsis_;
}
inline void AETextInfo::set_ellipsis(bool value) {
  set_has_ellipsis();
  ellipsis_ = value;
}

// optional uint32 leading = 12;
inline bool AETextInfo::has_leading() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AETextInfo::set_has_leading() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AETextInfo::clear_has_leading() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AETextInfo::clear_leading() {
  leading_ = 0u;
  clear_has_leading();
}
inline ::google::protobuf::uint32 AETextInfo::leading() const {
  return leading_;
}
inline void AETextInfo::set_leading(::google::protobuf::uint32 value) {
  set_has_leading();
  leading_ = value;
}

// optional bool isAllCaps = 13;
inline bool AETextInfo::has_isallcaps() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AETextInfo::set_has_isallcaps() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AETextInfo::clear_has_isallcaps() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AETextInfo::clear_isallcaps() {
  isallcaps_ = false;
  clear_has_isallcaps();
}
inline bool AETextInfo::isallcaps() const {
  return isallcaps_;
}
inline void AETextInfo::set_isallcaps(bool value) {
  set_has_isallcaps();
  isallcaps_ = value;
}

// -------------------------------------------------------------------

// AEMaskVertex

// required float x = 1;
inline bool AEMaskVertex::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEMaskVertex::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEMaskVertex::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEMaskVertex::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float AEMaskVertex::x() const {
  return x_;
}
inline void AEMaskVertex::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool AEMaskVertex::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEMaskVertex::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEMaskVertex::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEMaskVertex::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float AEMaskVertex::y() const {
  return y_;
}
inline void AEMaskVertex::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float tan_in_x = 3;
inline bool AEMaskVertex::has_tan_in_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AEMaskVertex::set_has_tan_in_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AEMaskVertex::clear_has_tan_in_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AEMaskVertex::clear_tan_in_x() {
  tan_in_x_ = 0;
  clear_has_tan_in_x();
}
inline float AEMaskVertex::tan_in_x() const {
  return tan_in_x_;
}
inline void AEMaskVertex::set_tan_in_x(float value) {
  set_has_tan_in_x();
  tan_in_x_ = value;
}

// required float tan_in_y = 4;
inline bool AEMaskVertex::has_tan_in_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AEMaskVertex::set_has_tan_in_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AEMaskVertex::clear_has_tan_in_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AEMaskVertex::clear_tan_in_y() {
  tan_in_y_ = 0;
  clear_has_tan_in_y();
}
inline float AEMaskVertex::tan_in_y() const {
  return tan_in_y_;
}
inline void AEMaskVertex::set_tan_in_y(float value) {
  set_has_tan_in_y();
  tan_in_y_ = value;
}

// required float tan_out_x = 5;
inline bool AEMaskVertex::has_tan_out_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AEMaskVertex::set_has_tan_out_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AEMaskVertex::clear_has_tan_out_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AEMaskVertex::clear_tan_out_x() {
  tan_out_x_ = 0;
  clear_has_tan_out_x();
}
inline float AEMaskVertex::tan_out_x() const {
  return tan_out_x_;
}
inline void AEMaskVertex::set_tan_out_x(float value) {
  set_has_tan_out_x();
  tan_out_x_ = value;
}

// required float tan_out_y = 6;
inline bool AEMaskVertex::has_tan_out_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AEMaskVertex::set_has_tan_out_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AEMaskVertex::clear_has_tan_out_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AEMaskVertex::clear_tan_out_y() {
  tan_out_y_ = 0;
  clear_has_tan_out_y();
}
inline float AEMaskVertex::tan_out_y() const {
  return tan_out_y_;
}
inline void AEMaskVertex::set_tan_out_y(float value) {
  set_has_tan_out_y();
  tan_out_y_ = value;
}

// -------------------------------------------------------------------

// AEMask

// required bool is_closed = 1;
inline bool AEMask::has_is_closed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEMask::set_has_is_closed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEMask::clear_has_is_closed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEMask::clear_is_closed() {
  is_closed_ = false;
  clear_has_is_closed();
}
inline bool AEMask::is_closed() const {
  return is_closed_;
}
inline void AEMask::set_is_closed(bool value) {
  set_has_is_closed();
  is_closed_ = value;
}

// required int32 mask_source_id = 2;
inline bool AEMask::has_mask_source_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEMask::set_has_mask_source_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEMask::clear_has_mask_source_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEMask::clear_mask_source_id() {
  mask_source_id_ = 0;
  clear_has_mask_source_id();
}
inline ::google::protobuf::int32 AEMask::mask_source_id() const {
  return mask_source_id_;
}
inline void AEMask::set_mask_source_id(::google::protobuf::int32 value) {
  set_has_mask_source_id();
  mask_source_id_ = value;
}

// -------------------------------------------------------------------

// AEEffectParam

// required string name = 1;
inline bool AEEffectParam::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEEffectParam::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEEffectParam::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEEffectParam::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AEEffectParam::name() const {
  return *name_;
}
inline void AEEffectParam::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AEEffectParam::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AEEffectParam::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AEEffectParam::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AEEffectParam::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float fvalue1 = 2;
inline bool AEEffectParam::has_fvalue1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEEffectParam::set_has_fvalue1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEEffectParam::clear_has_fvalue1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEEffectParam::clear_fvalue1() {
  fvalue1_ = 0;
  clear_has_fvalue1();
}
inline float AEEffectParam::fvalue1() const {
  return fvalue1_;
}
inline void AEEffectParam::set_fvalue1(float value) {
  set_has_fvalue1();
  fvalue1_ = value;
}

// optional float fvalue2 = 3;
inline bool AEEffectParam::has_fvalue2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AEEffectParam::set_has_fvalue2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AEEffectParam::clear_has_fvalue2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AEEffectParam::clear_fvalue2() {
  fvalue2_ = 0;
  clear_has_fvalue2();
}
inline float AEEffectParam::fvalue2() const {
  return fvalue2_;
}
inline void AEEffectParam::set_fvalue2(float value) {
  set_has_fvalue2();
  fvalue2_ = value;
}

// optional float fvalue3 = 4;
inline bool AEEffectParam::has_fvalue3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AEEffectParam::set_has_fvalue3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AEEffectParam::clear_has_fvalue3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AEEffectParam::clear_fvalue3() {
  fvalue3_ = 0;
  clear_has_fvalue3();
}
inline float AEEffectParam::fvalue3() const {
  return fvalue3_;
}
inline void AEEffectParam::set_fvalue3(float value) {
  set_has_fvalue3();
  fvalue3_ = value;
}

// -------------------------------------------------------------------

// AEEffect

// repeated .aefilter.AEEffectParam param = 1;
inline int AEEffect::param_size() const {
  return param_.size();
}
inline void AEEffect::clear_param() {
  param_.Clear();
}
inline const ::aefilter::AEEffectParam& AEEffect::param(int index) const {
  return param_.Get(index);
}
inline ::aefilter::AEEffectParam* AEEffect::mutable_param(int index) {
  return param_.Mutable(index);
}
inline ::aefilter::AEEffectParam* AEEffect::add_param() {
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEEffectParam >&
AEEffect::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEEffectParam >*
AEEffect::mutable_param() {
  return &param_;
}

// -------------------------------------------------------------------

// AELayer

// required string name = 1;
inline bool AELayer::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AELayer::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AELayer::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AELayer::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AELayer::name() const {
  return *name_;
}
inline void AELayer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AELayer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AELayer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AELayer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AELayer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 id = 3;
inline bool AELayer::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AELayer::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AELayer::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AELayer::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AELayer::id() const {
  return id_;
}
inline void AELayer::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 sourceid = 4;
inline bool AELayer::has_sourceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AELayer::set_has_sourceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AELayer::clear_has_sourceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AELayer::clear_sourceid() {
  sourceid_ = 0;
  clear_has_sourceid();
}
inline ::google::protobuf::int32 AELayer::sourceid() const {
  return sourceid_;
}
inline void AELayer::set_sourceid(::google::protobuf::int32 value) {
  set_has_sourceid();
  sourceid_ = value;
}

// required .aefilter.AETransform transform = 5;
inline bool AELayer::has_transform() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AELayer::set_has_transform() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AELayer::clear_has_transform() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AELayer::clear_transform() {
  if (transform_ != NULL) transform_->::aefilter::AETransform::Clear();
  clear_has_transform();
}
inline const ::aefilter::AETransform& AELayer::transform() const {
  return transform_ != NULL ? *transform_ : *default_instance_->transform_;
}
inline ::aefilter::AETransform* AELayer::mutable_transform() {
  set_has_transform();
  if (transform_ == NULL) transform_ = new ::aefilter::AETransform;
  return transform_;
}
inline ::aefilter::AETransform* AELayer::release_transform() {
  clear_has_transform();
  ::aefilter::AETransform* temp = transform_;
  transform_ = NULL;
  return temp;
}

// required bool acceptsshadows = 6;
inline bool AELayer::has_acceptsshadows() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AELayer::set_has_acceptsshadows() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AELayer::clear_has_acceptsshadows() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AELayer::clear_acceptsshadows() {
  acceptsshadows_ = false;
  clear_has_acceptsshadows();
}
inline bool AELayer::acceptsshadows() const {
  return acceptsshadows_;
}
inline void AELayer::set_acceptsshadows(bool value) {
  set_has_acceptsshadows();
  acceptsshadows_ = value;
}

// required bool acceptslights = 7;
inline bool AELayer::has_acceptslights() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AELayer::set_has_acceptslights() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AELayer::clear_has_acceptslights() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AELayer::clear_acceptslights() {
  acceptslights_ = false;
  clear_has_acceptslights();
}
inline bool AELayer::acceptslights() const {
  return acceptslights_;
}
inline void AELayer::set_acceptslights(bool value) {
  set_has_acceptslights();
  acceptslights_ = value;
}

// required bool castsshadows = 8;
inline bool AELayer::has_castsshadows() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AELayer::set_has_castsshadows() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AELayer::clear_has_castsshadows() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AELayer::clear_castsshadows() {
  castsshadows_ = false;
  clear_has_castsshadows();
}
inline bool AELayer::castsshadows() const {
  return castsshadows_;
}
inline void AELayer::set_castsshadows(bool value) {
  set_has_castsshadows();
  castsshadows_ = value;
}

// optional bool ishidden = 9;
inline bool AELayer::has_ishidden() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AELayer::set_has_ishidden() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AELayer::clear_has_ishidden() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AELayer::clear_ishidden() {
  ishidden_ = false;
  clear_has_ishidden();
}
inline bool AELayer::ishidden() const {
  return ishidden_;
}
inline void AELayer::set_ishidden(bool value) {
  set_has_ishidden();
  ishidden_ = value;
}

// optional .aefilter.AETextInfo textinfo = 10;
inline bool AELayer::has_textinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AELayer::set_has_textinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AELayer::clear_has_textinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AELayer::clear_textinfo() {
  if (textinfo_ != NULL) textinfo_->::aefilter::AETextInfo::Clear();
  clear_has_textinfo();
}
inline const ::aefilter::AETextInfo& AELayer::textinfo() const {
  return textinfo_ != NULL ? *textinfo_ : *default_instance_->textinfo_;
}
inline ::aefilter::AETextInfo* AELayer::mutable_textinfo() {
  set_has_textinfo();
  if (textinfo_ == NULL) textinfo_ = new ::aefilter::AETextInfo;
  return textinfo_;
}
inline ::aefilter::AETextInfo* AELayer::release_textinfo() {
  clear_has_textinfo();
  ::aefilter::AETextInfo* temp = textinfo_;
  textinfo_ = NULL;
  return temp;
}

// optional int32 parentid = 11;
inline bool AELayer::has_parentid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AELayer::set_has_parentid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AELayer::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AELayer::clear_parentid() {
  parentid_ = 0;
  clear_has_parentid();
}
inline ::google::protobuf::int32 AELayer::parentid() const {
  return parentid_;
}
inline void AELayer::set_parentid(::google::protobuf::int32 value) {
  set_has_parentid();
  parentid_ = value;
}

// repeated .aefilter.AEMask mask = 12;
inline int AELayer::mask_size() const {
  return mask_.size();
}
inline void AELayer::clear_mask() {
  mask_.Clear();
}
inline const ::aefilter::AEMask& AELayer::mask(int index) const {
  return mask_.Get(index);
}
inline ::aefilter::AEMask* AELayer::mutable_mask(int index) {
  return mask_.Mutable(index);
}
inline ::aefilter::AEMask* AELayer::add_mask() {
  return mask_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEMask >&
AELayer::mask() const {
  return mask_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEMask >*
AELayer::mutable_mask() {
  return &mask_;
}

// repeated .aefilter.AEEffect effect = 13;
inline int AELayer::effect_size() const {
  return effect_.size();
}
inline void AELayer::clear_effect() {
  effect_.Clear();
}
inline const ::aefilter::AEEffect& AELayer::effect(int index) const {
  return effect_.Get(index);
}
inline ::aefilter::AEEffect* AELayer::mutable_effect(int index) {
  return effect_.Mutable(index);
}
inline ::aefilter::AEEffect* AELayer::add_effect() {
  return effect_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEEffect >&
AELayer::effect() const {
  return effect_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEEffect >*
AELayer::mutable_effect() {
  return &effect_;
}

// optional string classname = 14;
inline bool AELayer::has_classname() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AELayer::set_has_classname() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AELayer::clear_has_classname() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AELayer::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& AELayer::classname() const {
  return *classname_;
}
inline void AELayer::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void AELayer::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void AELayer::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AELayer::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* AELayer::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .aefilter.AEKeyPair properties = 15;
inline int AELayer::properties_size() const {
  return properties_.size();
}
inline void AELayer::clear_properties() {
  properties_.Clear();
}
inline const ::aefilter::AEKeyPair& AELayer::properties(int index) const {
  return properties_.Get(index);
}
inline ::aefilter::AEKeyPair* AELayer::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::aefilter::AEKeyPair* AELayer::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair >&
AELayer::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair >*
AELayer::mutable_properties() {
  return &properties_;
}

// -------------------------------------------------------------------

// AECamera

// required string name = 1;
inline bool AECamera::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AECamera::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AECamera::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AECamera::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AECamera::name() const {
  return *name_;
}
inline void AECamera::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AECamera::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AECamera::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AECamera::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AECamera::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .aefilter.AETransform transform = 2;
inline bool AECamera::has_transform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AECamera::set_has_transform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AECamera::clear_has_transform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AECamera::clear_transform() {
  if (transform_ != NULL) transform_->::aefilter::AETransform::Clear();
  clear_has_transform();
}
inline const ::aefilter::AETransform& AECamera::transform() const {
  return transform_ != NULL ? *transform_ : *default_instance_->transform_;
}
inline ::aefilter::AETransform* AECamera::mutable_transform() {
  set_has_transform();
  if (transform_ == NULL) transform_ = new ::aefilter::AETransform;
  return transform_;
}
inline ::aefilter::AETransform* AECamera::release_transform() {
  clear_has_transform();
  ::aefilter::AETransform* temp = transform_;
  transform_ = NULL;
  return temp;
}

// required float FOV = 3;
inline bool AECamera::has_fov() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AECamera::set_has_fov() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AECamera::clear_has_fov() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AECamera::clear_fov() {
  fov_ = 0;
  clear_has_fov();
}
inline float AECamera::fov() const {
  return fov_;
}
inline void AECamera::set_fov(float value) {
  set_has_fov();
  fov_ = value;
}

// required int32 id = 4;
inline bool AECamera::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AECamera::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AECamera::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AECamera::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AECamera::id() const {
  return id_;
}
inline void AECamera::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated .aefilter.AEKeyPair properties = 5;
inline int AECamera::properties_size() const {
  return properties_.size();
}
inline void AECamera::clear_properties() {
  properties_.Clear();
}
inline const ::aefilter::AEKeyPair& AECamera::properties(int index) const {
  return properties_.Get(index);
}
inline ::aefilter::AEKeyPair* AECamera::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::aefilter::AEKeyPair* AECamera::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair >&
AECamera::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair >*
AECamera::mutable_properties() {
  return &properties_;
}

// optional int32 parentid = 11;
inline bool AECamera::has_parentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AECamera::set_has_parentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AECamera::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AECamera::clear_parentid() {
  parentid_ = 0;
  clear_has_parentid();
}
inline ::google::protobuf::int32 AECamera::parentid() const {
  return parentid_;
}
inline void AECamera::set_parentid(::google::protobuf::int32 value) {
  set_has_parentid();
  parentid_ = value;
}

// -------------------------------------------------------------------

// AELight

// required string name = 1;
inline bool AELight::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AELight::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AELight::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AELight::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AELight::name() const {
  return *name_;
}
inline void AELight::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AELight::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AELight::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AELight::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AELight::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .aefilter.AETransform transform = 2;
inline bool AELight::has_transform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AELight::set_has_transform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AELight::clear_has_transform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AELight::clear_transform() {
  if (transform_ != NULL) transform_->::aefilter::AETransform::Clear();
  clear_has_transform();
}
inline const ::aefilter::AETransform& AELight::transform() const {
  return transform_ != NULL ? *transform_ : *default_instance_->transform_;
}
inline ::aefilter::AETransform* AELight::mutable_transform() {
  set_has_transform();
  if (transform_ == NULL) transform_ = new ::aefilter::AETransform;
  return transform_;
}
inline ::aefilter::AETransform* AELight::release_transform() {
  clear_has_transform();
  ::aefilter::AETransform* temp = transform_;
  transform_ = NULL;
  return temp;
}

// required .aefilter.AELightType type = 3;
inline bool AELight::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AELight::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AELight::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AELight::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline aefilter::AELightType AELight::type() const {
  return static_cast< aefilter::AELightType >(type_);
}
inline void AELight::set_type(aefilter::AELightType value) {
  GOOGLE_DCHECK(aefilter::AELightType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .aefilter.AEVector color = 4;
inline bool AELight::has_color() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AELight::set_has_color() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AELight::clear_has_color() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AELight::clear_color() {
  if (color_ != NULL) color_->::aefilter::AEVector::Clear();
  clear_has_color();
}
inline const ::aefilter::AEVector& AELight::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::aefilter::AEVector* AELight::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::aefilter::AEVector;
  return color_;
}
inline ::aefilter::AEVector* AELight::release_color() {
  clear_has_color();
  ::aefilter::AEVector* temp = color_;
  color_ = NULL;
  return temp;
}

// required bool castsshadows = 5;
inline bool AELight::has_castsshadows() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AELight::set_has_castsshadows() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AELight::clear_has_castsshadows() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AELight::clear_castsshadows() {
  castsshadows_ = false;
  clear_has_castsshadows();
}
inline bool AELight::castsshadows() const {
  return castsshadows_;
}
inline void AELight::set_castsshadows(bool value) {
  set_has_castsshadows();
  castsshadows_ = value;
}

// required string parentname = 6;
inline bool AELight::has_parentname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AELight::set_has_parentname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AELight::clear_has_parentname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AELight::clear_parentname() {
  if (parentname_ != &::google::protobuf::internal::kEmptyString) {
    parentname_->clear();
  }
  clear_has_parentname();
}
inline const ::std::string& AELight::parentname() const {
  return *parentname_;
}
inline void AELight::set_parentname(const ::std::string& value) {
  set_has_parentname();
  if (parentname_ == &::google::protobuf::internal::kEmptyString) {
    parentname_ = new ::std::string;
  }
  parentname_->assign(value);
}
inline void AELight::set_parentname(const char* value) {
  set_has_parentname();
  if (parentname_ == &::google::protobuf::internal::kEmptyString) {
    parentname_ = new ::std::string;
  }
  parentname_->assign(value);
}
inline void AELight::set_parentname(const char* value, size_t size) {
  set_has_parentname();
  if (parentname_ == &::google::protobuf::internal::kEmptyString) {
    parentname_ = new ::std::string;
  }
  parentname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AELight::mutable_parentname() {
  set_has_parentname();
  if (parentname_ == &::google::protobuf::internal::kEmptyString) {
    parentname_ = new ::std::string;
  }
  return parentname_;
}
inline ::std::string* AELight::release_parentname() {
  clear_has_parentname();
  if (parentname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parentname_;
    parentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float radius = 7;
inline bool AELight::has_radius() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AELight::set_has_radius() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AELight::clear_has_radius() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AELight::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float AELight::radius() const {
  return radius_;
}
inline void AELight::set_radius(float value) {
  set_has_radius();
  radius_ = value;
}

// optional float falloff = 8;
inline bool AELight::has_falloff() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AELight::set_has_falloff() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AELight::clear_has_falloff() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AELight::clear_falloff() {
  falloff_ = 0;
  clear_has_falloff();
}
inline float AELight::falloff() const {
  return falloff_;
}
inline void AELight::set_falloff(float value) {
  set_has_falloff();
  falloff_ = value;
}

// optional float spotexponent = 9;
inline bool AELight::has_spotexponent() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AELight::set_has_spotexponent() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AELight::clear_has_spotexponent() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AELight::clear_spotexponent() {
  spotexponent_ = 0;
  clear_has_spotexponent();
}
inline float AELight::spotexponent() const {
  return spotexponent_;
}
inline void AELight::set_spotexponent(float value) {
  set_has_spotexponent();
  spotexponent_ = value;
}

// optional float spotcosine = 10;
inline bool AELight::has_spotcosine() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AELight::set_has_spotcosine() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AELight::clear_has_spotcosine() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AELight::clear_spotcosine() {
  spotcosine_ = 0;
  clear_has_spotcosine();
}
inline float AELight::spotcosine() const {
  return spotcosine_;
}
inline void AELight::set_spotcosine(float value) {
  set_has_spotcosine();
  spotcosine_ = value;
}

// required int32 id = 11;
inline bool AELight::has_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AELight::set_has_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AELight::clear_has_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AELight::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AELight::id() const {
  return id_;
}
inline void AELight::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// AETrackIdentifier

// required int32 targetid = 1;
inline bool AETrackIdentifier::has_targetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AETrackIdentifier::set_has_targetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AETrackIdentifier::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AETrackIdentifier::clear_targetid() {
  targetid_ = 0;
  clear_has_targetid();
}
inline ::google::protobuf::int32 AETrackIdentifier::targetid() const {
  return targetid_;
}
inline void AETrackIdentifier::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// required .aefilter.AEBinding binding = 2;
inline bool AETrackIdentifier::has_binding() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AETrackIdentifier::set_has_binding() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AETrackIdentifier::clear_has_binding() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AETrackIdentifier::clear_binding() {
  binding_ = 0;
  clear_has_binding();
}
inline aefilter::AEBinding AETrackIdentifier::binding() const {
  return static_cast< aefilter::AEBinding >(binding_);
}
inline void AETrackIdentifier::set_binding(aefilter::AEBinding value) {
  GOOGLE_DCHECK(aefilter::AEBinding_IsValid(value));
  set_has_binding();
  binding_ = value;
}

// -------------------------------------------------------------------

// AEComposition

// required string name = 1;
inline bool AEComposition::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEComposition::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEComposition::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEComposition::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AEComposition::name() const {
  return *name_;
}
inline void AEComposition::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AEComposition::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AEComposition::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AEComposition::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AEComposition::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float width = 2;
inline bool AEComposition::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEComposition::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEComposition::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEComposition::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float AEComposition::width() const {
  return width_;
}
inline void AEComposition::set_width(float value) {
  set_has_width();
  width_ = value;
}

// required float height = 3;
inline bool AEComposition::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AEComposition::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AEComposition::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AEComposition::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float AEComposition::height() const {
  return height_;
}
inline void AEComposition::set_height(float value) {
  set_has_height();
  height_ = value;
}

// required float defaultcameradistance = 4;
inline bool AEComposition::has_defaultcameradistance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AEComposition::set_has_defaultcameradistance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AEComposition::clear_has_defaultcameradistance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AEComposition::clear_defaultcameradistance() {
  defaultcameradistance_ = 0;
  clear_has_defaultcameradistance();
}
inline float AEComposition::defaultcameradistance() const {
  return defaultcameradistance_;
}
inline void AEComposition::set_defaultcameradistance(float value) {
  set_has_defaultcameradistance();
  defaultcameradistance_ = value;
}

// repeated .aefilter.AECamera camera = 5;
inline int AEComposition::camera_size() const {
  return camera_.size();
}
inline void AEComposition::clear_camera() {
  camera_.Clear();
}
inline const ::aefilter::AECamera& AEComposition::camera(int index) const {
  return camera_.Get(index);
}
inline ::aefilter::AECamera* AEComposition::mutable_camera(int index) {
  return camera_.Mutable(index);
}
inline ::aefilter::AECamera* AEComposition::add_camera() {
  return camera_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AECamera >&
AEComposition::camera() const {
  return camera_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AECamera >*
AEComposition::mutable_camera() {
  return &camera_;
}

// repeated .aefilter.AELayer layer = 6;
inline int AEComposition::layer_size() const {
  return layer_.size();
}
inline void AEComposition::clear_layer() {
  layer_.Clear();
}
inline const ::aefilter::AELayer& AEComposition::layer(int index) const {
  return layer_.Get(index);
}
inline ::aefilter::AELayer* AEComposition::mutable_layer(int index) {
  return layer_.Mutable(index);
}
inline ::aefilter::AELayer* AEComposition::add_layer() {
  return layer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AELayer >&
AEComposition::layer() const {
  return layer_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AELayer >*
AEComposition::mutable_layer() {
  return &layer_;
}

// repeated .aefilter.AELight lights = 7;
inline int AEComposition::lights_size() const {
  return lights_.size();
}
inline void AEComposition::clear_lights() {
  lights_.Clear();
}
inline const ::aefilter::AELight& AEComposition::lights(int index) const {
  return lights_.Get(index);
}
inline ::aefilter::AELight* AEComposition::mutable_lights(int index) {
  return lights_.Mutable(index);
}
inline ::aefilter::AELight* AEComposition::add_lights() {
  return lights_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AELight >&
AEComposition::lights() const {
  return lights_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AELight >*
AEComposition::mutable_lights() {
  return &lights_;
}

// optional string classname = 8;
inline bool AEComposition::has_classname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AEComposition::set_has_classname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AEComposition::clear_has_classname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AEComposition::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& AEComposition::classname() const {
  return *classname_;
}
inline void AEComposition::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void AEComposition::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void AEComposition::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AEComposition::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* AEComposition::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .aefilter.AEColor bgcolor = 9;
inline bool AEComposition::has_bgcolor() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AEComposition::set_has_bgcolor() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AEComposition::clear_has_bgcolor() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AEComposition::clear_bgcolor() {
  if (bgcolor_ != NULL) bgcolor_->::aefilter::AEColor::Clear();
  clear_has_bgcolor();
}
inline const ::aefilter::AEColor& AEComposition::bgcolor() const {
  return bgcolor_ != NULL ? *bgcolor_ : *default_instance_->bgcolor_;
}
inline ::aefilter::AEColor* AEComposition::mutable_bgcolor() {
  set_has_bgcolor();
  if (bgcolor_ == NULL) bgcolor_ = new ::aefilter::AEColor;
  return bgcolor_;
}
inline ::aefilter::AEColor* AEComposition::release_bgcolor() {
  clear_has_bgcolor();
  ::aefilter::AEColor* temp = bgcolor_;
  bgcolor_ = NULL;
  return temp;
}

// optional string DEPRECATED_stylename = 10;
inline bool AEComposition::has_deprecated_stylename() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AEComposition::set_has_deprecated_stylename() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AEComposition::clear_has_deprecated_stylename() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AEComposition::clear_deprecated_stylename() {
  if (deprecated_stylename_ != &::google::protobuf::internal::kEmptyString) {
    deprecated_stylename_->clear();
  }
  clear_has_deprecated_stylename();
}
inline const ::std::string& AEComposition::deprecated_stylename() const {
  return *deprecated_stylename_;
}
inline void AEComposition::set_deprecated_stylename(const ::std::string& value) {
  set_has_deprecated_stylename();
  if (deprecated_stylename_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_stylename_ = new ::std::string;
  }
  deprecated_stylename_->assign(value);
}
inline void AEComposition::set_deprecated_stylename(const char* value) {
  set_has_deprecated_stylename();
  if (deprecated_stylename_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_stylename_ = new ::std::string;
  }
  deprecated_stylename_->assign(value);
}
inline void AEComposition::set_deprecated_stylename(const char* value, size_t size) {
  set_has_deprecated_stylename();
  if (deprecated_stylename_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_stylename_ = new ::std::string;
  }
  deprecated_stylename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AEComposition::mutable_deprecated_stylename() {
  set_has_deprecated_stylename();
  if (deprecated_stylename_ == &::google::protobuf::internal::kEmptyString) {
    deprecated_stylename_ = new ::std::string;
  }
  return deprecated_stylename_;
}
inline ::std::string* AEComposition::release_deprecated_stylename() {
  clear_has_deprecated_stylename();
  if (deprecated_stylename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deprecated_stylename_;
    deprecated_stylename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string packagename = 11;
inline bool AEComposition::has_packagename() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AEComposition::set_has_packagename() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AEComposition::clear_has_packagename() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AEComposition::clear_packagename() {
  if (packagename_ != &::google::protobuf::internal::kEmptyString) {
    packagename_->clear();
  }
  clear_has_packagename();
}
inline const ::std::string& AEComposition::packagename() const {
  return *packagename_;
}
inline void AEComposition::set_packagename(const ::std::string& value) {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    packagename_ = new ::std::string;
  }
  packagename_->assign(value);
}
inline void AEComposition::set_packagename(const char* value) {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    packagename_ = new ::std::string;
  }
  packagename_->assign(value);
}
inline void AEComposition::set_packagename(const char* value, size_t size) {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    packagename_ = new ::std::string;
  }
  packagename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AEComposition::mutable_packagename() {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    packagename_ = new ::std::string;
  }
  return packagename_;
}
inline ::std::string* AEComposition::release_packagename() {
  clear_has_packagename();
  if (packagename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packagename_;
    packagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .aefilter.AEKeyPair properties = 12;
inline int AEComposition::properties_size() const {
  return properties_.size();
}
inline void AEComposition::clear_properties() {
  properties_.Clear();
}
inline const ::aefilter::AEKeyPair& AEComposition::properties(int index) const {
  return properties_.Get(index);
}
inline ::aefilter::AEKeyPair* AEComposition::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::aefilter::AEKeyPair* AEComposition::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair >&
AEComposition::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeyPair >*
AEComposition::mutable_properties() {
  return &properties_;
}

// repeated string childtemplates = 13;
inline int AEComposition::childtemplates_size() const {
  return childtemplates_.size();
}
inline void AEComposition::clear_childtemplates() {
  childtemplates_.Clear();
}
inline const ::std::string& AEComposition::childtemplates(int index) const {
  return childtemplates_.Get(index);
}
inline ::std::string* AEComposition::mutable_childtemplates(int index) {
  return childtemplates_.Mutable(index);
}
inline void AEComposition::set_childtemplates(int index, const ::std::string& value) {
  childtemplates_.Mutable(index)->assign(value);
}
inline void AEComposition::set_childtemplates(int index, const char* value) {
  childtemplates_.Mutable(index)->assign(value);
}
inline void AEComposition::set_childtemplates(int index, const char* value, size_t size) {
  childtemplates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AEComposition::add_childtemplates() {
  return childtemplates_.Add();
}
inline void AEComposition::add_childtemplates(const ::std::string& value) {
  childtemplates_.Add()->assign(value);
}
inline void AEComposition::add_childtemplates(const char* value) {
  childtemplates_.Add()->assign(value);
}
inline void AEComposition::add_childtemplates(const char* value, size_t size) {
  childtemplates_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AEComposition::childtemplates() const {
  return childtemplates_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AEComposition::mutable_childtemplates() {
  return &childtemplates_;
}

// -------------------------------------------------------------------

// AESource

// required int32 uid = 1;
inline bool AESource::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AESource::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AESource::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AESource::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AESource::uid() const {
  return uid_;
}
inline void AESource::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required .aefilter.AESourceType srctype = 2;
inline bool AESource::has_srctype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AESource::set_has_srctype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AESource::clear_has_srctype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AESource::clear_srctype() {
  srctype_ = 0;
  clear_has_srctype();
}
inline aefilter::AESourceType AESource::srctype() const {
  return static_cast< aefilter::AESourceType >(srctype_);
}
inline void AESource::set_srctype(aefilter::AESourceType value) {
  GOOGLE_DCHECK(aefilter::AESourceType_IsValid(value));
  set_has_srctype();
  srctype_ = value;
}

// optional string name = 3;
inline bool AESource::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AESource::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AESource::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AESource::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AESource::name() const {
  return *name_;
}
inline void AESource::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AESource::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AESource::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AESource::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AESource::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .aefilter.AEComposition comp = 4;
inline bool AESource::has_comp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AESource::set_has_comp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AESource::clear_has_comp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AESource::clear_comp() {
  if (comp_ != NULL) comp_->::aefilter::AEComposition::Clear();
  clear_has_comp();
}
inline const ::aefilter::AEComposition& AESource::comp() const {
  return comp_ != NULL ? *comp_ : *default_instance_->comp_;
}
inline ::aefilter::AEComposition* AESource::mutable_comp() {
  set_has_comp();
  if (comp_ == NULL) comp_ = new ::aefilter::AEComposition;
  return comp_;
}
inline ::aefilter::AEComposition* AESource::release_comp() {
  clear_has_comp();
  ::aefilter::AEComposition* temp = comp_;
  comp_ = NULL;
  return temp;
}

// optional .aefilter.AEColor color = 5;
inline bool AESource::has_color() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AESource::set_has_color() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AESource::clear_has_color() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AESource::clear_color() {
  if (color_ != NULL) color_->::aefilter::AEColor::Clear();
  clear_has_color();
}
inline const ::aefilter::AEColor& AESource::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::aefilter::AEColor* AESource::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::aefilter::AEColor;
  return color_;
}
inline ::aefilter::AEColor* AESource::release_color() {
  clear_has_color();
  ::aefilter::AEColor* temp = color_;
  color_ = NULL;
  return temp;
}

// optional int32 width = 6;
inline bool AESource::has_width() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AESource::set_has_width() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AESource::clear_has_width() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AESource::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 AESource::width() const {
  return width_;
}
inline void AESource::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 7;
inline bool AESource::has_height() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AESource::set_has_height() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AESource::clear_has_height() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AESource::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 AESource::height() const {
  return height_;
}
inline void AESource::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 numberOfFrames = 9;
inline bool AESource::has_numberofframes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AESource::set_has_numberofframes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AESource::clear_has_numberofframes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AESource::clear_numberofframes() {
  numberofframes_ = 0;
  clear_has_numberofframes();
}
inline ::google::protobuf::int32 AESource::numberofframes() const {
  return numberofframes_;
}
inline void AESource::set_numberofframes(::google::protobuf::int32 value) {
  set_has_numberofframes();
  numberofframes_ = value;
}

// optional int32 fps = 10;
inline bool AESource::has_fps() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AESource::set_has_fps() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AESource::clear_has_fps() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AESource::clear_fps() {
  fps_ = 0;
  clear_has_fps();
}
inline ::google::protobuf::int32 AESource::fps() const {
  return fps_;
}
inline void AESource::set_fps(::google::protobuf::int32 value) {
  set_has_fps();
  fps_ = value;
}

// optional int32 loops = 11;
inline bool AESource::has_loops() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AESource::set_has_loops() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AESource::clear_has_loops() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AESource::clear_loops() {
  loops_ = 0;
  clear_has_loops();
}
inline ::google::protobuf::int32 AESource::loops() const {
  return loops_;
}
inline void AESource::set_loops(::google::protobuf::int32 value) {
  set_has_loops();
  loops_ = value;
}

// optional bool copy_source = 12;
inline bool AESource::has_copy_source() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AESource::set_has_copy_source() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AESource::clear_has_copy_source() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AESource::clear_copy_source() {
  copy_source_ = false;
  clear_has_copy_source();
}
inline bool AESource::copy_source() const {
  return copy_source_;
}
inline void AESource::set_copy_source(bool value) {
  set_has_copy_source();
  copy_source_ = value;
}

// optional string file_name = 13;
inline bool AESource::has_file_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AESource::set_has_file_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AESource::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AESource::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& AESource::file_name() const {
  return *file_name_;
}
inline void AESource::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void AESource::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void AESource::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AESource::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* AESource::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AELayout

// required .aefilter.AEComposition activecomp = 1;
inline bool AELayout::has_activecomp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AELayout::set_has_activecomp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AELayout::clear_has_activecomp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AELayout::clear_activecomp() {
  if (activecomp_ != NULL) activecomp_->::aefilter::AEComposition::Clear();
  clear_has_activecomp();
}
inline const ::aefilter::AEComposition& AELayout::activecomp() const {
  return activecomp_ != NULL ? *activecomp_ : *default_instance_->activecomp_;
}
inline ::aefilter::AEComposition* AELayout::mutable_activecomp() {
  set_has_activecomp();
  if (activecomp_ == NULL) activecomp_ = new ::aefilter::AEComposition;
  return activecomp_;
}
inline ::aefilter::AEComposition* AELayout::release_activecomp() {
  clear_has_activecomp();
  ::aefilter::AEComposition* temp = activecomp_;
  activecomp_ = NULL;
  return temp;
}

// repeated .aefilter.AESource sources = 2;
inline int AELayout::sources_size() const {
  return sources_.size();
}
inline void AELayout::clear_sources() {
  sources_.Clear();
}
inline const ::aefilter::AESource& AELayout::sources(int index) const {
  return sources_.Get(index);
}
inline ::aefilter::AESource* AELayout::mutable_sources(int index) {
  return sources_.Mutable(index);
}
inline ::aefilter::AESource* AELayout::add_sources() {
  return sources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AESource >&
AELayout::sources() const {
  return sources_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AESource >*
AELayout::mutable_sources() {
  return &sources_;
}

// -------------------------------------------------------------------

// AEKeytimeEase

// required float speedIn = 1;
inline bool AEKeytimeEase::has_speedin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEKeytimeEase::set_has_speedin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEKeytimeEase::clear_has_speedin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEKeytimeEase::clear_speedin() {
  speedin_ = 0;
  clear_has_speedin();
}
inline float AEKeytimeEase::speedin() const {
  return speedin_;
}
inline void AEKeytimeEase::set_speedin(float value) {
  set_has_speedin();
  speedin_ = value;
}

// required float influenceIn = 2;
inline bool AEKeytimeEase::has_influencein() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEKeytimeEase::set_has_influencein() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEKeytimeEase::clear_has_influencein() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEKeytimeEase::clear_influencein() {
  influencein_ = 0;
  clear_has_influencein();
}
inline float AEKeytimeEase::influencein() const {
  return influencein_;
}
inline void AEKeytimeEase::set_influencein(float value) {
  set_has_influencein();
  influencein_ = value;
}

// required float speedOut = 3;
inline bool AEKeytimeEase::has_speedout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AEKeytimeEase::set_has_speedout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AEKeytimeEase::clear_has_speedout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AEKeytimeEase::clear_speedout() {
  speedout_ = 0;
  clear_has_speedout();
}
inline float AEKeytimeEase::speedout() const {
  return speedout_;
}
inline void AEKeytimeEase::set_speedout(float value) {
  set_has_speedout();
  speedout_ = value;
}

// required float influenceOut = 4;
inline bool AEKeytimeEase::has_influenceout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AEKeytimeEase::set_has_influenceout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AEKeytimeEase::clear_has_influenceout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AEKeytimeEase::clear_influenceout() {
  influenceout_ = 0;
  clear_has_influenceout();
}
inline float AEKeytimeEase::influenceout() const {
  return influenceout_;
}
inline void AEKeytimeEase::set_influenceout(float value) {
  set_has_influenceout();
  influenceout_ = value;
}

// -------------------------------------------------------------------

// AEKeytime

// required .aefilter.AEDataType datatype = 1;
inline bool AEKeytime::has_datatype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEKeytime::set_has_datatype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEKeytime::clear_has_datatype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEKeytime::clear_datatype() {
  datatype_ = 0;
  clear_has_datatype();
}
inline aefilter::AEDataType AEKeytime::datatype() const {
  return static_cast< aefilter::AEDataType >(datatype_);
}
inline void AEKeytime::set_datatype(aefilter::AEDataType value) {
  GOOGLE_DCHECK(aefilter::AEDataType_IsValid(value));
  set_has_datatype();
  datatype_ = value;
}

// required float timeOffset = 2;
inline bool AEKeytime::has_timeoffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEKeytime::set_has_timeoffset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEKeytime::clear_has_timeoffset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEKeytime::clear_timeoffset() {
  timeoffset_ = 0;
  clear_has_timeoffset();
}
inline float AEKeytime::timeoffset() const {
  return timeoffset_;
}
inline void AEKeytime::set_timeoffset(float value) {
  set_has_timeoffset();
  timeoffset_ = value;
}

// required .aefilter.AEIType inttype = 3;
inline bool AEKeytime::has_inttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AEKeytime::set_has_inttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AEKeytime::clear_has_inttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AEKeytime::clear_inttype() {
  inttype_ = 0;
  clear_has_inttype();
}
inline aefilter::AEIType AEKeytime::inttype() const {
  return static_cast< aefilter::AEIType >(inttype_);
}
inline void AEKeytime::set_inttype(aefilter::AEIType value) {
  GOOGLE_DCHECK(aefilter::AEIType_IsValid(value));
  set_has_inttype();
  inttype_ = value;
}

// optional float obsoleteSpeedIn = 5;
inline bool AEKeytime::has_obsoletespeedin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AEKeytime::set_has_obsoletespeedin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AEKeytime::clear_has_obsoletespeedin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AEKeytime::clear_obsoletespeedin() {
  obsoletespeedin_ = 0;
  clear_has_obsoletespeedin();
}
inline float AEKeytime::obsoletespeedin() const {
  return obsoletespeedin_;
}
inline void AEKeytime::set_obsoletespeedin(float value) {
  set_has_obsoletespeedin();
  obsoletespeedin_ = value;
}

// optional float obsoleteInfluenceIn = 6;
inline bool AEKeytime::has_obsoleteinfluencein() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AEKeytime::set_has_obsoleteinfluencein() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AEKeytime::clear_has_obsoleteinfluencein() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AEKeytime::clear_obsoleteinfluencein() {
  obsoleteinfluencein_ = 0;
  clear_has_obsoleteinfluencein();
}
inline float AEKeytime::obsoleteinfluencein() const {
  return obsoleteinfluencein_;
}
inline void AEKeytime::set_obsoleteinfluencein(float value) {
  set_has_obsoleteinfluencein();
  obsoleteinfluencein_ = value;
}

// optional float obsoleteSpeedOut = 7;
inline bool AEKeytime::has_obsoletespeedout() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AEKeytime::set_has_obsoletespeedout() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AEKeytime::clear_has_obsoletespeedout() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AEKeytime::clear_obsoletespeedout() {
  obsoletespeedout_ = 0;
  clear_has_obsoletespeedout();
}
inline float AEKeytime::obsoletespeedout() const {
  return obsoletespeedout_;
}
inline void AEKeytime::set_obsoletespeedout(float value) {
  set_has_obsoletespeedout();
  obsoletespeedout_ = value;
}

// optional float obsoleteInfluenceOut = 8;
inline bool AEKeytime::has_obsoleteinfluenceout() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AEKeytime::set_has_obsoleteinfluenceout() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AEKeytime::clear_has_obsoleteinfluenceout() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AEKeytime::clear_obsoleteinfluenceout() {
  obsoleteinfluenceout_ = 0;
  clear_has_obsoleteinfluenceout();
}
inline float AEKeytime::obsoleteinfluenceout() const {
  return obsoleteinfluenceout_;
}
inline void AEKeytime::set_obsoleteinfluenceout(float value) {
  set_has_obsoleteinfluenceout();
  obsoleteinfluenceout_ = value;
}

// optional float sInTangentX = 9;
inline bool AEKeytime::has_sintangentx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AEKeytime::set_has_sintangentx() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AEKeytime::clear_has_sintangentx() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AEKeytime::clear_sintangentx() {
  sintangentx_ = 0;
  clear_has_sintangentx();
}
inline float AEKeytime::sintangentx() const {
  return sintangentx_;
}
inline void AEKeytime::set_sintangentx(float value) {
  set_has_sintangentx();
  sintangentx_ = value;
}

// optional float sInTangentY = 10;
inline bool AEKeytime::has_sintangenty() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AEKeytime::set_has_sintangenty() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AEKeytime::clear_has_sintangenty() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AEKeytime::clear_sintangenty() {
  sintangenty_ = 0;
  clear_has_sintangenty();
}
inline float AEKeytime::sintangenty() const {
  return sintangenty_;
}
inline void AEKeytime::set_sintangenty(float value) {
  set_has_sintangenty();
  sintangenty_ = value;
}

// optional float sInTangentZ = 11;
inline bool AEKeytime::has_sintangentz() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AEKeytime::set_has_sintangentz() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AEKeytime::clear_has_sintangentz() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AEKeytime::clear_sintangentz() {
  sintangentz_ = 0;
  clear_has_sintangentz();
}
inline float AEKeytime::sintangentz() const {
  return sintangentz_;
}
inline void AEKeytime::set_sintangentz(float value) {
  set_has_sintangentz();
  sintangentz_ = value;
}

// optional float sOutTangentX = 12;
inline bool AEKeytime::has_souttangentx() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AEKeytime::set_has_souttangentx() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AEKeytime::clear_has_souttangentx() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AEKeytime::clear_souttangentx() {
  souttangentx_ = 0;
  clear_has_souttangentx();
}
inline float AEKeytime::souttangentx() const {
  return souttangentx_;
}
inline void AEKeytime::set_souttangentx(float value) {
  set_has_souttangentx();
  souttangentx_ = value;
}

// optional float sOutTangentY = 13;
inline bool AEKeytime::has_souttangenty() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AEKeytime::set_has_souttangenty() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AEKeytime::clear_has_souttangenty() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AEKeytime::clear_souttangenty() {
  souttangenty_ = 0;
  clear_has_souttangenty();
}
inline float AEKeytime::souttangenty() const {
  return souttangenty_;
}
inline void AEKeytime::set_souttangenty(float value) {
  set_has_souttangenty();
  souttangenty_ = value;
}

// optional float sOutTangentZ = 14;
inline bool AEKeytime::has_souttangentz() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AEKeytime::set_has_souttangentz() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AEKeytime::clear_has_souttangentz() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AEKeytime::clear_souttangentz() {
  souttangentz_ = 0;
  clear_has_souttangentz();
}
inline float AEKeytime::souttangentz() const {
  return souttangentz_;
}
inline void AEKeytime::set_souttangentz(float value) {
  set_has_souttangentz();
  souttangentz_ = value;
}

// optional float fvalue1 = 15;
inline bool AEKeytime::has_fvalue1() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AEKeytime::set_has_fvalue1() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AEKeytime::clear_has_fvalue1() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AEKeytime::clear_fvalue1() {
  fvalue1_ = 0;
  clear_has_fvalue1();
}
inline float AEKeytime::fvalue1() const {
  return fvalue1_;
}
inline void AEKeytime::set_fvalue1(float value) {
  set_has_fvalue1();
  fvalue1_ = value;
}

// optional float fvalue2 = 16;
inline bool AEKeytime::has_fvalue2() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AEKeytime::set_has_fvalue2() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AEKeytime::clear_has_fvalue2() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AEKeytime::clear_fvalue2() {
  fvalue2_ = 0;
  clear_has_fvalue2();
}
inline float AEKeytime::fvalue2() const {
  return fvalue2_;
}
inline void AEKeytime::set_fvalue2(float value) {
  set_has_fvalue2();
  fvalue2_ = value;
}

// optional float fvalue3 = 17;
inline bool AEKeytime::has_fvalue3() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AEKeytime::set_has_fvalue3() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AEKeytime::clear_has_fvalue3() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AEKeytime::clear_fvalue3() {
  fvalue3_ = 0;
  clear_has_fvalue3();
}
inline float AEKeytime::fvalue3() const {
  return fvalue3_;
}
inline void AEKeytime::set_fvalue3(float value) {
  set_has_fvalue3();
  fvalue3_ = value;
}

// optional int32 ivalue1 = 18;
inline bool AEKeytime::has_ivalue1() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AEKeytime::set_has_ivalue1() {
  _has_bits_[0] |= 0x00010000u;
}
inline void AEKeytime::clear_has_ivalue1() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void AEKeytime::clear_ivalue1() {
  ivalue1_ = 0;
  clear_has_ivalue1();
}
inline ::google::protobuf::int32 AEKeytime::ivalue1() const {
  return ivalue1_;
}
inline void AEKeytime::set_ivalue1(::google::protobuf::int32 value) {
  set_has_ivalue1();
  ivalue1_ = value;
}

// repeated .aefilter.AEKeytimeEase easeValues = 19;
inline int AEKeytime::easevalues_size() const {
  return easevalues_.size();
}
inline void AEKeytime::clear_easevalues() {
  easevalues_.Clear();
}
inline const ::aefilter::AEKeytimeEase& AEKeytime::easevalues(int index) const {
  return easevalues_.Get(index);
}
inline ::aefilter::AEKeytimeEase* AEKeytime::mutable_easevalues(int index) {
  return easevalues_.Mutable(index);
}
inline ::aefilter::AEKeytimeEase* AEKeytime::add_easevalues() {
  return easevalues_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeytimeEase >&
AEKeytime::easevalues() const {
  return easevalues_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeytimeEase >*
AEKeytime::mutable_easevalues() {
  return &easevalues_;
}

// optional bool isCookedKeytime = 20;
inline bool AEKeytime::has_iscookedkeytime() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AEKeytime::set_has_iscookedkeytime() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AEKeytime::clear_has_iscookedkeytime() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AEKeytime::clear_iscookedkeytime() {
  iscookedkeytime_ = false;
  clear_has_iscookedkeytime();
}
inline bool AEKeytime::iscookedkeytime() const {
  return iscookedkeytime_;
}
inline void AEKeytime::set_iscookedkeytime(bool value) {
  set_has_iscookedkeytime();
  iscookedkeytime_ = value;
}

// -------------------------------------------------------------------

// AETrack

// required .aefilter.AEBinding binding = 1;
inline bool AETrack::has_binding() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AETrack::set_has_binding() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AETrack::clear_has_binding() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AETrack::clear_binding() {
  binding_ = 0;
  clear_has_binding();
}
inline aefilter::AEBinding AETrack::binding() const {
  return static_cast< aefilter::AEBinding >(binding_);
}
inline void AETrack::set_binding(aefilter::AEBinding value) {
  GOOGLE_DCHECK(aefilter::AEBinding_IsValid(value));
  set_has_binding();
  binding_ = value;
}

// required int32 targetid = 2;
inline bool AETrack::has_targetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AETrack::set_has_targetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AETrack::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AETrack::clear_targetid() {
  targetid_ = 0;
  clear_has_targetid();
}
inline ::google::protobuf::int32 AETrack::targetid() const {
  return targetid_;
}
inline void AETrack::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// required string targetname = 3;
inline bool AETrack::has_targetname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AETrack::set_has_targetname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AETrack::clear_has_targetname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AETrack::clear_targetname() {
  if (targetname_ != &::google::protobuf::internal::kEmptyString) {
    targetname_->clear();
  }
  clear_has_targetname();
}
inline const ::std::string& AETrack::targetname() const {
  return *targetname_;
}
inline void AETrack::set_targetname(const ::std::string& value) {
  set_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    targetname_ = new ::std::string;
  }
  targetname_->assign(value);
}
inline void AETrack::set_targetname(const char* value) {
  set_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    targetname_ = new ::std::string;
  }
  targetname_->assign(value);
}
inline void AETrack::set_targetname(const char* value, size_t size) {
  set_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    targetname_ = new ::std::string;
  }
  targetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AETrack::mutable_targetname() {
  set_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    targetname_ = new ::std::string;
  }
  return targetname_;
}
inline ::std::string* AETrack::release_targetname() {
  clear_has_targetname();
  if (targetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targetname_;
    targetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .aefilter.AEKeytime keytimes = 4;
inline int AETrack::keytimes_size() const {
  return keytimes_.size();
}
inline void AETrack::clear_keytimes() {
  keytimes_.Clear();
}
inline const ::aefilter::AEKeytime& AETrack::keytimes(int index) const {
  return keytimes_.Get(index);
}
inline ::aefilter::AEKeytime* AETrack::mutable_keytimes(int index) {
  return keytimes_.Mutable(index);
}
inline ::aefilter::AEKeytime* AETrack::add_keytimes() {
  return keytimes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeytime >&
AETrack::keytimes() const {
  return keytimes_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEKeytime >*
AETrack::mutable_keytimes() {
  return &keytimes_;
}

// optional string trackName = 5;
inline bool AETrack::has_trackname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AETrack::set_has_trackname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AETrack::clear_has_trackname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AETrack::clear_trackname() {
  if (trackname_ != &::google::protobuf::internal::kEmptyString) {
    trackname_->clear();
  }
  clear_has_trackname();
}
inline const ::std::string& AETrack::trackname() const {
  return *trackname_;
}
inline void AETrack::set_trackname(const ::std::string& value) {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  trackname_->assign(value);
}
inline void AETrack::set_trackname(const char* value) {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  trackname_->assign(value);
}
inline void AETrack::set_trackname(const char* value, size_t size) {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  trackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AETrack::mutable_trackname() {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  return trackname_;
}
inline ::std::string* AETrack::release_trackname() {
  clear_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trackname_;
    trackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AEMarker

// required float starttime = 1;
inline bool AEMarker::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEMarker::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEMarker::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEMarker::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline float AEMarker::starttime() const {
  return starttime_;
}
inline void AEMarker::set_starttime(float value) {
  set_has_starttime();
  starttime_ = value;
}

// required float duration = 2;
inline bool AEMarker::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEMarker::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEMarker::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEMarker::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float AEMarker::duration() const {
  return duration_;
}
inline void AEMarker::set_duration(float value) {
  set_has_duration();
  duration_ = value;
}

// required string name = 3;
inline bool AEMarker::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AEMarker::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AEMarker::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AEMarker::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AEMarker::name() const {
  return *name_;
}
inline void AEMarker::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AEMarker::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AEMarker::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AEMarker::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AEMarker::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .aefilter.AETrackIdentifier tracksSelection = 4;
inline int AEMarker::tracksselection_size() const {
  return tracksselection_.size();
}
inline void AEMarker::clear_tracksselection() {
  tracksselection_.Clear();
}
inline const ::aefilter::AETrackIdentifier& AEMarker::tracksselection(int index) const {
  return tracksselection_.Get(index);
}
inline ::aefilter::AETrackIdentifier* AEMarker::mutable_tracksselection(int index) {
  return tracksselection_.Mutable(index);
}
inline ::aefilter::AETrackIdentifier* AEMarker::add_tracksselection() {
  return tracksselection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AETrackIdentifier >&
AEMarker::tracksselection() const {
  return tracksselection_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AETrackIdentifier >*
AEMarker::mutable_tracksselection() {
  return &tracksselection_;
}

// optional bool alltracks = 5;
inline bool AEMarker::has_alltracks() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AEMarker::set_has_alltracks() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AEMarker::clear_has_alltracks() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AEMarker::clear_alltracks() {
  alltracks_ = false;
  clear_has_alltracks();
}
inline bool AEMarker::alltracks() const {
  return alltracks_;
}
inline void AEMarker::set_alltracks(bool value) {
  set_has_alltracks();
  alltracks_ = value;
}

// optional int32 id = 6;
inline bool AEMarker::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AEMarker::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AEMarker::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AEMarker::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AEMarker::id() const {
  return id_;
}
inline void AEMarker::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional bool looping = 7;
inline bool AEMarker::has_looping() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AEMarker::set_has_looping() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AEMarker::clear_has_looping() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AEMarker::clear_looping() {
  looping_ = false;
  clear_has_looping();
}
inline bool AEMarker::looping() const {
  return looping_;
}
inline void AEMarker::set_looping(bool value) {
  set_has_looping();
  looping_ = value;
}

// -------------------------------------------------------------------

// AETimeline

// repeated .aefilter.AETrack tracks = 1;
inline int AETimeline::tracks_size() const {
  return tracks_.size();
}
inline void AETimeline::clear_tracks() {
  tracks_.Clear();
}
inline const ::aefilter::AETrack& AETimeline::tracks(int index) const {
  return tracks_.Get(index);
}
inline ::aefilter::AETrack* AETimeline::mutable_tracks(int index) {
  return tracks_.Mutable(index);
}
inline ::aefilter::AETrack* AETimeline::add_tracks() {
  return tracks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AETrack >&
AETimeline::tracks() const {
  return tracks_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AETrack >*
AETimeline::mutable_tracks() {
  return &tracks_;
}

// repeated .aefilter.AEMarker markers = 2;
inline int AETimeline::markers_size() const {
  return markers_.size();
}
inline void AETimeline::clear_markers() {
  markers_.Clear();
}
inline const ::aefilter::AEMarker& AETimeline::markers(int index) const {
  return markers_.Get(index);
}
inline ::aefilter::AEMarker* AETimeline::mutable_markers(int index) {
  return markers_.Mutable(index);
}
inline ::aefilter::AEMarker* AETimeline::add_markers() {
  return markers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aefilter::AEMarker >&
AETimeline::markers() const {
  return markers_;
}
inline ::google::protobuf::RepeatedPtrField< ::aefilter::AEMarker >*
AETimeline::mutable_markers() {
  return &markers_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace aefilter

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< aefilter::AESourceType>() {
  return aefilter::AESourceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< aefilter::AEJustificationType>() {
  return aefilter::AEJustificationType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< aefilter::AELightType>() {
  return aefilter::AELightType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< aefilter::AEBinding>() {
  return aefilter::AEBinding_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< aefilter::AEDataType>() {
  return aefilter::AEDataType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< aefilter::AEIType>() {
  return aefilter::AEIType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AEFilter_2eproto__INCLUDED
#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning (pop)
#endif
