#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#pragma clang diagnostic ignored "-Wshorten-64-to-32" //not available on all gcc platforms
#elif defined(__GNUC__) || defined(__GNUG__) //also defined with clang, must be second
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#elif defined(_MSC_VER)
#pragma warning (push, 0)
#endif
#ifndef __clang_analyzer__
// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "AEFilter.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace aefilter {

namespace {

const ::google::protobuf::Descriptor* AEVector_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AEVector_reflection_ = NULL;
const ::google::protobuf::Descriptor* AEColor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AEColor_reflection_ = NULL;
const ::google::protobuf::Descriptor* AETransform_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AETransform_reflection_ = NULL;
const ::google::protobuf::Descriptor* AEKeyPair_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AEKeyPair_reflection_ = NULL;
const ::google::protobuf::Descriptor* AETextInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AETextInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* AEMaskVertex_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AEMaskVertex_reflection_ = NULL;
const ::google::protobuf::Descriptor* AEMask_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AEMask_reflection_ = NULL;
const ::google::protobuf::Descriptor* AEEffectParam_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AEEffectParam_reflection_ = NULL;
const ::google::protobuf::Descriptor* AEEffect_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AEEffect_reflection_ = NULL;
const ::google::protobuf::Descriptor* AELayer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AELayer_reflection_ = NULL;
const ::google::protobuf::Descriptor* AECamera_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AECamera_reflection_ = NULL;
const ::google::protobuf::Descriptor* AELight_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AELight_reflection_ = NULL;
const ::google::protobuf::Descriptor* AETrackIdentifier_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AETrackIdentifier_reflection_ = NULL;
const ::google::protobuf::Descriptor* AEComposition_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AEComposition_reflection_ = NULL;
const ::google::protobuf::Descriptor* AESource_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AESource_reflection_ = NULL;
const ::google::protobuf::Descriptor* AELayout_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AELayout_reflection_ = NULL;
const ::google::protobuf::Descriptor* AEKeytimeEase_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AEKeytimeEase_reflection_ = NULL;
const ::google::protobuf::Descriptor* AEKeytime_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AEKeytime_reflection_ = NULL;
const ::google::protobuf::Descriptor* AETrack_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AETrack_reflection_ = NULL;
const ::google::protobuf::Descriptor* AEMarker_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AEMarker_reflection_ = NULL;
const ::google::protobuf::Descriptor* AETimeline_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AETimeline_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* AESourceType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* AEJustificationType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* AELightType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* AEBinding_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* AEDataType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* AEIType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_AEFilter_2eproto() {
  protobuf_AddDesc_AEFilter_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "AEFilter.proto");
  GOOGLE_CHECK(file != NULL);
  AEVector_descriptor_ = file->message_type(0);
  static const int AEVector_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEVector, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEVector, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEVector, z_),
  };
  AEVector_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AEVector_descriptor_,
      AEVector::default_instance_,
      AEVector_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEVector, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEVector, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AEVector));
  AEColor_descriptor_ = file->message_type(1);
  static const int AEColor_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEColor, alpha_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEColor, red_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEColor, green_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEColor, blue_),
  };
  AEColor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AEColor_descriptor_,
      AEColor::default_instance_,
      AEColor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEColor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEColor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AEColor));
  AETransform_descriptor_ = file->message_type(2);
  static const int AETransform_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETransform, anchorpoint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETransform, scale_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETransform, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETransform, orientation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETransform, rotationx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETransform, rotationy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETransform, rotationz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETransform, opacity_),
  };
  AETransform_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AETransform_descriptor_,
      AETransform::default_instance_,
      AETransform_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETransform, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETransform, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AETransform));
  AEKeyPair_descriptor_ = file->message_type(3);
  static const int AEKeyPair_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeyPair, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeyPair, value_),
  };
  AEKeyPair_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AEKeyPair_descriptor_,
      AEKeyPair::default_instance_,
      AEKeyPair_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeyPair, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeyPair, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AEKeyPair));
  AETextInfo_descriptor_ = file->message_type(4);
  static const int AETextInfo_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, justification_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, fontsize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, fontcolor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, fontname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, ispointtext_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, boundswidth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, boundsheight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, islabel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, text_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, multiline_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, ellipsis_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, leading_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, isallcaps_),
  };
  AETextInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AETextInfo_descriptor_,
      AETextInfo::default_instance_,
      AETextInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETextInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AETextInfo));
  AEMaskVertex_descriptor_ = file->message_type(5);
  static const int AEMaskVertex_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMaskVertex, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMaskVertex, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMaskVertex, tan_in_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMaskVertex, tan_in_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMaskVertex, tan_out_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMaskVertex, tan_out_y_),
  };
  AEMaskVertex_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AEMaskVertex_descriptor_,
      AEMaskVertex::default_instance_,
      AEMaskVertex_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMaskVertex, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMaskVertex, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AEMaskVertex));
  AEMask_descriptor_ = file->message_type(6);
  static const int AEMask_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMask, is_closed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMask, mask_source_id_),
  };
  AEMask_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AEMask_descriptor_,
      AEMask::default_instance_,
      AEMask_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMask, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMask, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AEMask));
  AEEffectParam_descriptor_ = file->message_type(7);
  static const int AEEffectParam_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEEffectParam, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEEffectParam, fvalue1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEEffectParam, fvalue2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEEffectParam, fvalue3_),
  };
  AEEffectParam_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AEEffectParam_descriptor_,
      AEEffectParam::default_instance_,
      AEEffectParam_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEEffectParam, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEEffectParam, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AEEffectParam));
  AEEffect_descriptor_ = file->message_type(8);
  static const int AEEffect_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEEffect, param_),
  };
  AEEffect_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AEEffect_descriptor_,
      AEEffect::default_instance_,
      AEEffect_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEEffect, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEEffect, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AEEffect));
  AELayer_descriptor_ = file->message_type(9);
  static const int AELayer_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, sourceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, transform_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, acceptsshadows_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, acceptslights_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, castsshadows_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, ishidden_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, textinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, parentid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, mask_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, effect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, classname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, properties_),
  };
  AELayer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AELayer_descriptor_,
      AELayer::default_instance_,
      AELayer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AELayer));
  AECamera_descriptor_ = file->message_type(10);
  static const int AECamera_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AECamera, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AECamera, transform_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AECamera, fov_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AECamera, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AECamera, properties_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AECamera, parentid_),
  };
  AECamera_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AECamera_descriptor_,
      AECamera::default_instance_,
      AECamera_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AECamera, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AECamera, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AECamera));
  AELight_descriptor_ = file->message_type(11);
  static const int AELight_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELight, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELight, transform_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELight, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELight, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELight, castsshadows_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELight, parentname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELight, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELight, falloff_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELight, spotexponent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELight, spotcosine_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELight, id_),
  };
  AELight_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AELight_descriptor_,
      AELight::default_instance_,
      AELight_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELight, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELight, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AELight));
  AETrackIdentifier_descriptor_ = file->message_type(12);
  static const int AETrackIdentifier_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETrackIdentifier, targetid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETrackIdentifier, binding_),
  };
  AETrackIdentifier_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AETrackIdentifier_descriptor_,
      AETrackIdentifier::default_instance_,
      AETrackIdentifier_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETrackIdentifier, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETrackIdentifier, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AETrackIdentifier));
  AEComposition_descriptor_ = file->message_type(13);
  static const int AEComposition_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, defaultcameradistance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, camera_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, layer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, lights_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, classname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, bgcolor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, deprecated_stylename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, packagename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, properties_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, childtemplates_),
  };
  AEComposition_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AEComposition_descriptor_,
      AEComposition::default_instance_,
      AEComposition_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEComposition, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AEComposition));
  AESource_descriptor_ = file->message_type(14);
  static const int AESource_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, srctype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, comp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, numberofframes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, fps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, loops_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, copy_source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, file_name_),
  };
  AESource_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AESource_descriptor_,
      AESource::default_instance_,
      AESource_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AESource, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AESource));
  AELayout_descriptor_ = file->message_type(15);
  static const int AELayout_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayout, activecomp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayout, sources_),
  };
  AELayout_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AELayout_descriptor_,
      AELayout::default_instance_,
      AELayout_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayout, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AELayout, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AELayout));
  AEKeytimeEase_descriptor_ = file->message_type(16);
  static const int AEKeytimeEase_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytimeEase, speedin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytimeEase, influencein_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytimeEase, speedout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytimeEase, influenceout_),
  };
  AEKeytimeEase_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AEKeytimeEase_descriptor_,
      AEKeytimeEase::default_instance_,
      AEKeytimeEase_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytimeEase, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytimeEase, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AEKeytimeEase));
  AEKeytime_descriptor_ = file->message_type(17);
  static const int AEKeytime_offsets_[19] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, datatype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, timeoffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, inttype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, obsoletespeedin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, obsoleteinfluencein_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, obsoletespeedout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, obsoleteinfluenceout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, sintangentx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, sintangenty_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, sintangentz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, souttangentx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, souttangenty_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, souttangentz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, fvalue1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, fvalue2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, fvalue3_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, ivalue1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, easevalues_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, iscookedkeytime_),
  };
  AEKeytime_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AEKeytime_descriptor_,
      AEKeytime::default_instance_,
      AEKeytime_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEKeytime, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AEKeytime));
  AETrack_descriptor_ = file->message_type(18);
  static const int AETrack_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETrack, binding_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETrack, targetid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETrack, targetname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETrack, keytimes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETrack, trackname_),
  };
  AETrack_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AETrack_descriptor_,
      AETrack::default_instance_,
      AETrack_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETrack, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETrack, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AETrack));
  AEMarker_descriptor_ = file->message_type(19);
  static const int AEMarker_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMarker, starttime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMarker, duration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMarker, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMarker, tracksselection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMarker, alltracks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMarker, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMarker, looping_),
  };
  AEMarker_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AEMarker_descriptor_,
      AEMarker::default_instance_,
      AEMarker_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMarker, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AEMarker, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AEMarker));
  AETimeline_descriptor_ = file->message_type(20);
  static const int AETimeline_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETimeline, tracks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETimeline, markers_),
  };
  AETimeline_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AETimeline_descriptor_,
      AETimeline::default_instance_,
      AETimeline_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETimeline, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AETimeline, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AETimeline));
  AESourceType_descriptor_ = file->enum_type(0);
  AEJustificationType_descriptor_ = file->enum_type(1);
  AELightType_descriptor_ = file->enum_type(2);
  AEBinding_descriptor_ = file->enum_type(3);
  AEDataType_descriptor_ = file->enum_type(4);
  AEIType_descriptor_ = file->enum_type(5);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_AEFilter_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AEVector_descriptor_, &AEVector::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AEColor_descriptor_, &AEColor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AETransform_descriptor_, &AETransform::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AEKeyPair_descriptor_, &AEKeyPair::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AETextInfo_descriptor_, &AETextInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AEMaskVertex_descriptor_, &AEMaskVertex::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AEMask_descriptor_, &AEMask::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AEEffectParam_descriptor_, &AEEffectParam::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AEEffect_descriptor_, &AEEffect::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AELayer_descriptor_, &AELayer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AECamera_descriptor_, &AECamera::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AELight_descriptor_, &AELight::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AETrackIdentifier_descriptor_, &AETrackIdentifier::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AEComposition_descriptor_, &AEComposition::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AESource_descriptor_, &AESource::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AELayout_descriptor_, &AELayout::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AEKeytimeEase_descriptor_, &AEKeytimeEase::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AEKeytime_descriptor_, &AEKeytime::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AETrack_descriptor_, &AETrack::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AEMarker_descriptor_, &AEMarker::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AETimeline_descriptor_, &AETimeline::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_AEFilter_2eproto() {
  delete AEVector::default_instance_;
  delete AEVector_reflection_;
  delete AEColor::default_instance_;
  delete AEColor_reflection_;
  delete AETransform::default_instance_;
  delete AETransform_reflection_;
  delete AEKeyPair::default_instance_;
  delete AEKeyPair_reflection_;
  delete AETextInfo::default_instance_;
  delete AETextInfo_reflection_;
  delete AEMaskVertex::default_instance_;
  delete AEMaskVertex_reflection_;
  delete AEMask::default_instance_;
  delete AEMask_reflection_;
  delete AEEffectParam::default_instance_;
  delete AEEffectParam_reflection_;
  delete AEEffect::default_instance_;
  delete AEEffect_reflection_;
  delete AELayer::default_instance_;
  delete AELayer_reflection_;
  delete AECamera::default_instance_;
  delete AECamera_reflection_;
  delete AELight::default_instance_;
  delete AELight_reflection_;
  delete AETrackIdentifier::default_instance_;
  delete AETrackIdentifier_reflection_;
  delete AEComposition::default_instance_;
  delete AEComposition_reflection_;
  delete AESource::default_instance_;
  delete AESource_reflection_;
  delete AELayout::default_instance_;
  delete AELayout_reflection_;
  delete AEKeytimeEase::default_instance_;
  delete AEKeytimeEase_reflection_;
  delete AEKeytime::default_instance_;
  delete AEKeytime_reflection_;
  delete AETrack::default_instance_;
  delete AETrack_reflection_;
  delete AEMarker::default_instance_;
  delete AEMarker_reflection_;
  delete AETimeline::default_instance_;
  delete AETimeline_reflection_;
}

void protobuf_AddDesc_AEFilter_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016AEFilter.proto\022\010aefilter\"+\n\010AEVector\022\t"
    "\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n\001z\030\003 \002(\002\"B\n\007AECol"
    "or\022\r\n\005alpha\030\001 \002(\001\022\013\n\003red\030\002 \002(\001\022\r\n\005green\030"
    "\003 \002(\001\022\014\n\004blue\030\004 \002(\001\"\362\001\n\013AETransform\022\'\n\013a"
    "nchorPoint\030\001 \002(\0132\022.aefilter.AEVector\022!\n\005"
    "scale\030\002 \002(\0132\022.aefilter.AEVector\022$\n\010posit"
    "ion\030\003 \002(\0132\022.aefilter.AEVector\022\'\n\013orienta"
    "tion\030\004 \002(\0132\022.aefilter.AEVector\022\021\n\trotati"
    "onX\030\005 \002(\002\022\021\n\trotationY\030\006 \002(\002\022\021\n\trotation"
    "Z\030\007 \002(\002\022\017\n\007opacity\030\010 \002(\002\"\'\n\tAEKeyPair\022\013\n"
    "\003key\030\001 \002(\t\022\r\n\005value\030\002 \002(\t\"\264\002\n\nAETextInfo"
    "\0224\n\rjustification\030\001 \002(\0162\035.aefilter.AEJus"
    "tificationType\022\020\n\010fontSize\030\002 \002(\005\022$\n\tfont"
    "Color\030\003 \002(\0132\021.aefilter.AEColor\022\020\n\010fontNa"
    "me\030\004 \002(\t\022\023\n\013isPointText\030\005 \002(\010\022\023\n\013boundsW"
    "idth\030\006 \001(\005\022\024\n\014boundsHeight\030\007 \001(\005\022\017\n\007isLa"
    "bel\030\010 \001(\010\022\014\n\004text\030\t \001(\t\022\021\n\tmultiline\030\n \001"
    "(\010\022\020\n\010ellipsis\030\013 \001(\010\022\017\n\007leading\030\014 \001(\r\022\021\n"
    "\tisAllCaps\030\r \001(\010\"n\n\014AEMaskVertex\022\t\n\001x\030\001 "
    "\002(\002\022\t\n\001y\030\002 \002(\002\022\020\n\010tan_in_x\030\003 \002(\002\022\020\n\010tan_"
    "in_y\030\004 \002(\002\022\021\n\ttan_out_x\030\005 \002(\002\022\021\n\ttan_out"
    "_y\030\006 \002(\002\"3\n\006AEMask\022\021\n\tis_closed\030\001 \002(\010\022\026\n"
    "\016mask_source_id\030\002 \002(\005\"P\n\rAEEffectParam\022\014"
    "\n\004name\030\001 \002(\t\022\017\n\007fvalue1\030\002 \001(\002\022\017\n\007fvalue2"
    "\030\003 \001(\002\022\017\n\007fvalue3\030\004 \001(\002\"2\n\010AEEffect\022&\n\005p"
    "aram\030\001 \003(\0132\027.aefilter.AEEffectParam\"\360\002\n\007"
    "AELayer\022\014\n\004name\030\001 \002(\t\022\n\n\002id\030\003 \002(\005\022\020\n\010sou"
    "rceid\030\004 \002(\005\022(\n\ttransform\030\005 \002(\0132\025.aefilte"
    "r.AETransform\022\026\n\016acceptsshadows\030\006 \002(\010\022\025\n"
    "\racceptslights\030\007 \002(\010\022\024\n\014castsshadows\030\010 \002"
    "(\010\022\020\n\010ishidden\030\t \001(\010\022&\n\010textinfo\030\n \001(\0132\024"
    ".aefilter.AETextInfo\022\020\n\010parentid\030\013 \001(\005\022\036"
    "\n\004mask\030\014 \003(\0132\020.aefilter.AEMask\022\"\n\006effect"
    "\030\r \003(\0132\022.aefilter.AEEffect\022\021\n\tclassname\030"
    "\016 \001(\t\022\'\n\nproperties\030\017 \003(\0132\023.aefilter.AEK"
    "eyPair\"\226\001\n\010AECamera\022\014\n\004name\030\001 \002(\t\022(\n\ttra"
    "nsform\030\002 \002(\0132\025.aefilter.AETransform\022\013\n\003F"
    "OV\030\003 \002(\002\022\n\n\002id\030\004 \002(\005\022\'\n\nproperties\030\005 \003(\013"
    "2\023.aefilter.AEKeyPair\022\020\n\010parentid\030\013 \001(\005\""
    "\212\002\n\007AELight\022\014\n\004name\030\001 \002(\t\022(\n\ttransform\030\002"
    " \002(\0132\025.aefilter.AETransform\022#\n\004type\030\003 \002("
    "\0162\025.aefilter.AELightType\022!\n\005color\030\004 \002(\0132"
    "\022.aefilter.AEVector\022\024\n\014castsshadows\030\005 \002("
    "\010\022\022\n\nparentname\030\006 \002(\t\022\016\n\006radius\030\007 \001(\002\022\017\n"
    "\007falloff\030\010 \001(\002\022\024\n\014spotexponent\030\t \001(\002\022\022\n\n"
    "spotcosine\030\n \001(\002\022\n\n\002id\030\013 \002(\005\"K\n\021AETrackI"
    "dentifier\022\020\n\010targetid\030\001 \002(\005\022$\n\007binding\030\002"
    " \002(\0162\023.aefilter.AEBinding\"\357\002\n\rAEComposit"
    "ion\022\014\n\004name\030\001 \002(\t\022\r\n\005width\030\002 \002(\002\022\016\n\006heig"
    "ht\030\003 \002(\002\022\035\n\025defaultcameradistance\030\004 \002(\002\022"
    "\"\n\006camera\030\005 \003(\0132\022.aefilter.AECamera\022 \n\005l"
    "ayer\030\006 \003(\0132\021.aefilter.AELayer\022!\n\006lights\030"
    "\007 \003(\0132\021.aefilter.AELight\022\021\n\tclassname\030\010 "
    "\001(\t\022\"\n\007bgcolor\030\t \001(\0132\021.aefilter.AEColor\022"
    "\034\n\024DEPRECATED_stylename\030\n \001(\t\022\023\n\013package"
    "name\030\013 \001(\t\022\'\n\nproperties\030\014 \003(\0132\023.aefilte"
    "r.AEKeyPair\022\026\n\016childtemplates\030\r \003(\t\"\222\002\n\010"
    "AESource\022\013\n\003uid\030\001 \002(\005\022\'\n\007srctype\030\002 \002(\0162\026"
    ".aefilter.AESourceType\022\014\n\004name\030\003 \001(\t\022%\n\004"
    "comp\030\004 \001(\0132\027.aefilter.AEComposition\022 \n\005c"
    "olor\030\005 \001(\0132\021.aefilter.AEColor\022\r\n\005width\030\006"
    " \001(\005\022\016\n\006height\030\007 \001(\005\022\026\n\016numberOfFrames\030\t"
    " \001(\005\022\013\n\003fps\030\n \001(\005\022\r\n\005loops\030\013 \001(\005\022\023\n\013copy"
    "_source\030\014 \001(\010\022\021\n\tfile_name\030\r \001(\t\"\\\n\010AELa"
    "yout\022+\n\nactivecomp\030\001 \002(\0132\027.aefilter.AECo"
    "mposition\022#\n\007sources\030\002 \003(\0132\022.aefilter.AE"
    "Source\"]\n\rAEKeytimeEase\022\017\n\007speedIn\030\001 \002(\002"
    "\022\023\n\013influenceIn\030\002 \002(\002\022\020\n\010speedOut\030\003 \002(\002\022"
    "\024\n\014influenceOut\030\004 \002(\002\"\344\003\n\tAEKeytime\022&\n\010d"
    "atatype\030\001 \002(\0162\024.aefilter.AEDataType\022\022\n\nt"
    "imeOffset\030\002 \002(\002\022\"\n\007inttype\030\003 \002(\0162\021.aefil"
    "ter.AEIType\022\027\n\017obsoleteSpeedIn\030\005 \001(\002\022\033\n\023"
    "obsoleteInfluenceIn\030\006 \001(\002\022\030\n\020obsoleteSpe"
    "edOut\030\007 \001(\002\022\034\n\024obsoleteInfluenceOut\030\010 \001("
    "\002\022\023\n\013sInTangentX\030\t \001(\002\022\023\n\013sInTangentY\030\n "
    "\001(\002\022\023\n\013sInTangentZ\030\013 \001(\002\022\024\n\014sOutTangentX"
    "\030\014 \001(\002\022\024\n\014sOutTangentY\030\r \001(\002\022\024\n\014sOutTang"
    "entZ\030\016 \001(\002\022\017\n\007fvalue1\030\017 \001(\002\022\017\n\007fvalue2\030\020"
    " \001(\002\022\017\n\007fvalue3\030\021 \001(\002\022\017\n\007ivalue1\030\022 \001(\005\022+"
    "\n\neaseValues\030\023 \003(\0132\027.aefilter.AEKeytimeE"
    "ase\022\027\n\017isCookedKeytime\030\024 \001(\010\"\217\001\n\007AETrack"
    "\022$\n\007binding\030\001 \002(\0162\023.aefilter.AEBinding\022\020"
    "\n\010targetid\030\002 \002(\005\022\022\n\ntargetname\030\003 \002(\t\022%\n\010"
    "keytimes\030\004 \003(\0132\023.aefilter.AEKeytime\022\021\n\tt"
    "rackName\030\005 \001(\t\"\243\001\n\010AEMarker\022\021\n\tstarttime"
    "\030\001 \002(\002\022\020\n\010duration\030\002 \002(\002\022\014\n\004name\030\003 \002(\t\0224"
    "\n\017tracksSelection\030\004 \003(\0132\033.aefilter.AETra"
    "ckIdentifier\022\021\n\talltracks\030\005 \001(\010\022\n\n\002id\030\006 "
    "\001(\005\022\017\n\007looping\030\007 \001(\010\"T\n\nAETimeline\022!\n\006tr"
    "acks\030\001 \003(\0132\021.aefilter.AETrack\022#\n\007markers"
    "\030\002 \003(\0132\022.aefilter.AEMarker*\312\001\n\014AESourceT"
    "ype\022\017\n\013AE_COMP_SRC\020\000\022\020\n\014AE_IMAGE_SRC\020\001\022\020"
    "\n\014AE_SOLID_SRC\020\002\022\017\n\013AE_NULL_SRC\020\003\022\027\n\023AE_"
    "IMAGE_NPATCH_SRC\020\004\022\017\n\013AE_MASK_SRC\020\005\022\017\n\013A"
    "E_SRC_NONE\020\006\022\021\n\rAE_SPRITE_SRC\020\007\022\025\n\021AE_AD"
    "JUSTMENT_SRC\020\010\022\017\n\013AE_FONT_SRC\020\t*p\n\023AEJus"
    "tificationType\022 \n\023AE_TEXT_UNSUPPORTED\020\377\377"
    "\377\377\377\377\377\377\377\001\022\020\n\014AE_TEXT_LEFT\020\000\022\021\n\rAE_TEXT_RI"
    "GHT\020\001\022\022\n\016AE_TEXT_CENTER\020\002*a\n\013AELightType"
    "\022\025\n\021AE_LIGHT_PARALLEL\020\000\022\021\n\rAE_LIGHT_SPOT"
    "\020\001\022\022\n\016AE_LIGHT_POINT\020\002\022\024\n\020AE_LIGHT_AMBIE"
    "NT\020\003*\355\001\n\tAEBinding\022\014\n\010POSITION\020\000\022\016\n\nROTA"
    "TION_X\020\001\022\016\n\nROTATION_Y\020\002\022\016\n\nROTATION_Z\020\003"
    "\022\017\n\013ORIENTATION\020\004\022\t\n\005SCALE\020\005\022\013\n\007OPACITY\020"
    "\006\022\022\n\016SEP_POSITION_X\020\007\022\022\n\016SEP_POSITION_Y\020"
    "\010\022\022\n\016SEP_POSITION_Z\020\t\022\016\n\nIS_VISIBLE\020\n\022\020\n"
    "\014ANCHOR_POINT\020\013\022\n\n\006CUSTOM\020\014\022\017\n\013BINDING_M"
    "AX\020\r*b\n\nAEDataType\022\021\n\rAE_FLOAT_DATA\020\000\022\030\n"
    "\024AE_FLOAT_VECTOR_DATA\020\001\022\017\n\013AE_INT_DATA\020\002"
    "\022\026\n\022AE_QUATERNION_DATA\020\003*]\n\007AEIType\022\022\n\016A"
    "E_INTERP_NONE\020\000\022\024\n\020AE_INTERP_LINEAR\020\001\022\024\n"
    "\020AE_INTERP_BEZIER\020\002\022\022\n\016AE_INTERP_HOLD\020\003B"
    "\002H\001", 4483);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "AEFilter.proto", &protobuf_RegisterTypes);
  AEVector::default_instance_ = new AEVector();
  AEColor::default_instance_ = new AEColor();
  AETransform::default_instance_ = new AETransform();
  AEKeyPair::default_instance_ = new AEKeyPair();
  AETextInfo::default_instance_ = new AETextInfo();
  AEMaskVertex::default_instance_ = new AEMaskVertex();
  AEMask::default_instance_ = new AEMask();
  AEEffectParam::default_instance_ = new AEEffectParam();
  AEEffect::default_instance_ = new AEEffect();
  AELayer::default_instance_ = new AELayer();
  AECamera::default_instance_ = new AECamera();
  AELight::default_instance_ = new AELight();
  AETrackIdentifier::default_instance_ = new AETrackIdentifier();
  AEComposition::default_instance_ = new AEComposition();
  AESource::default_instance_ = new AESource();
  AELayout::default_instance_ = new AELayout();
  AEKeytimeEase::default_instance_ = new AEKeytimeEase();
  AEKeytime::default_instance_ = new AEKeytime();
  AETrack::default_instance_ = new AETrack();
  AEMarker::default_instance_ = new AEMarker();
  AETimeline::default_instance_ = new AETimeline();
  AEVector::default_instance_->InitAsDefaultInstance();
  AEColor::default_instance_->InitAsDefaultInstance();
  AETransform::default_instance_->InitAsDefaultInstance();
  AEKeyPair::default_instance_->InitAsDefaultInstance();
  AETextInfo::default_instance_->InitAsDefaultInstance();
  AEMaskVertex::default_instance_->InitAsDefaultInstance();
  AEMask::default_instance_->InitAsDefaultInstance();
  AEEffectParam::default_instance_->InitAsDefaultInstance();
  AEEffect::default_instance_->InitAsDefaultInstance();
  AELayer::default_instance_->InitAsDefaultInstance();
  AECamera::default_instance_->InitAsDefaultInstance();
  AELight::default_instance_->InitAsDefaultInstance();
  AETrackIdentifier::default_instance_->InitAsDefaultInstance();
  AEComposition::default_instance_->InitAsDefaultInstance();
  AESource::default_instance_->InitAsDefaultInstance();
  AELayout::default_instance_->InitAsDefaultInstance();
  AEKeytimeEase::default_instance_->InitAsDefaultInstance();
  AEKeytime::default_instance_->InitAsDefaultInstance();
  AETrack::default_instance_->InitAsDefaultInstance();
  AEMarker::default_instance_->InitAsDefaultInstance();
  AETimeline::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_AEFilter_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_AEFilter_2eproto {
  StaticDescriptorInitializer_AEFilter_2eproto() {
    protobuf_AddDesc_AEFilter_2eproto();
  }
} static_descriptor_initializer_AEFilter_2eproto_;

const ::google::protobuf::EnumDescriptor* AESourceType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AESourceType_descriptor_;
}
bool AESourceType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* AEJustificationType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEJustificationType_descriptor_;
}
bool AEJustificationType_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* AELightType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AELightType_descriptor_;
}
bool AELightType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* AEBinding_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEBinding_descriptor_;
}
bool AEBinding_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* AEDataType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEDataType_descriptor_;
}
bool AEDataType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* AEIType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEIType_descriptor_;
}
bool AEIType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int AEVector::kXFieldNumber;
const int AEVector::kYFieldNumber;
const int AEVector::kZFieldNumber;
#endif  // !_MSC_VER

AEVector::AEVector()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AEVector::InitAsDefaultInstance() {
}

AEVector::AEVector(const AEVector& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AEVector::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AEVector::~AEVector() {
  SharedDtor();
}

void AEVector::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AEVector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AEVector::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEVector_descriptor_;
}

const AEVector& AEVector::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AEVector* AEVector::default_instance_ = NULL;

AEVector* AEVector::New() const {
  return new AEVector;
}

void AEVector::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    z_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AEVector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }
      
      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }
      
      // required float z = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AEVector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }
  
  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }
  
  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AEVector::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }
  
  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }
  
  // required float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AEVector::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }
    
    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }
    
    // required float z = 3;
    if (has_z()) {
      total_size += 1 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AEVector::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AEVector* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AEVector*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AEVector::MergeFrom(const AEVector& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AEVector::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AEVector::CopyFrom(const AEVector& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AEVector::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void AEVector::Swap(AEVector* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AEVector::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AEVector_descriptor_;
  metadata.reflection = AEVector_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AEColor::kAlphaFieldNumber;
const int AEColor::kRedFieldNumber;
const int AEColor::kGreenFieldNumber;
const int AEColor::kBlueFieldNumber;
#endif  // !_MSC_VER

AEColor::AEColor()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AEColor::InitAsDefaultInstance() {
}

AEColor::AEColor(const AEColor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AEColor::SharedCtor() {
  _cached_size_ = 0;
  alpha_ = 0;
  red_ = 0;
  green_ = 0;
  blue_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AEColor::~AEColor() {
  SharedDtor();
}

void AEColor::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AEColor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AEColor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEColor_descriptor_;
}

const AEColor& AEColor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AEColor* AEColor::default_instance_ = NULL;

AEColor* AEColor::New() const {
  return new AEColor;
}

void AEColor::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    alpha_ = 0;
    red_ = 0;
    green_ = 0;
    blue_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AEColor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double alpha = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &alpha_)));
          set_has_alpha();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_red;
        break;
      }
      
      // required double red = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_red:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &red_)));
          set_has_red();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_green;
        break;
      }
      
      // required double green = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_green:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &green_)));
          set_has_green();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(33)) goto parse_blue;
        break;
      }
      
      // required double blue = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_blue:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &blue_)));
          set_has_blue();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AEColor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double alpha = 1;
  if (has_alpha()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->alpha(), output);
  }
  
  // required double red = 2;
  if (has_red()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->red(), output);
  }
  
  // required double green = 3;
  if (has_green()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->green(), output);
  }
  
  // required double blue = 4;
  if (has_blue()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->blue(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AEColor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double alpha = 1;
  if (has_alpha()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->alpha(), target);
  }
  
  // required double red = 2;
  if (has_red()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->red(), target);
  }
  
  // required double green = 3;
  if (has_green()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->green(), target);
  }
  
  // required double blue = 4;
  if (has_blue()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->blue(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AEColor::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double alpha = 1;
    if (has_alpha()) {
      total_size += 1 + 8;
    }
    
    // required double red = 2;
    if (has_red()) {
      total_size += 1 + 8;
    }
    
    // required double green = 3;
    if (has_green()) {
      total_size += 1 + 8;
    }
    
    // required double blue = 4;
    if (has_blue()) {
      total_size += 1 + 8;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AEColor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AEColor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AEColor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AEColor::MergeFrom(const AEColor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_alpha()) {
      set_alpha(from.alpha());
    }
    if (from.has_red()) {
      set_red(from.red());
    }
    if (from.has_green()) {
      set_green(from.green());
    }
    if (from.has_blue()) {
      set_blue(from.blue());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AEColor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AEColor::CopyFrom(const AEColor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AEColor::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

void AEColor::Swap(AEColor* other) {
  if (other != this) {
    std::swap(alpha_, other->alpha_);
    std::swap(red_, other->red_);
    std::swap(green_, other->green_);
    std::swap(blue_, other->blue_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AEColor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AEColor_descriptor_;
  metadata.reflection = AEColor_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AETransform::kAnchorPointFieldNumber;
const int AETransform::kScaleFieldNumber;
const int AETransform::kPositionFieldNumber;
const int AETransform::kOrientationFieldNumber;
const int AETransform::kRotationXFieldNumber;
const int AETransform::kRotationYFieldNumber;
const int AETransform::kRotationZFieldNumber;
const int AETransform::kOpacityFieldNumber;
#endif  // !_MSC_VER

AETransform::AETransform()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AETransform::InitAsDefaultInstance() {
  anchorpoint_ = const_cast< ::aefilter::AEVector*>(&::aefilter::AEVector::default_instance());
  scale_ = const_cast< ::aefilter::AEVector*>(&::aefilter::AEVector::default_instance());
  position_ = const_cast< ::aefilter::AEVector*>(&::aefilter::AEVector::default_instance());
  orientation_ = const_cast< ::aefilter::AEVector*>(&::aefilter::AEVector::default_instance());
}

AETransform::AETransform(const AETransform& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AETransform::SharedCtor() {
  _cached_size_ = 0;
  anchorpoint_ = NULL;
  scale_ = NULL;
  position_ = NULL;
  orientation_ = NULL;
  rotationx_ = 0;
  rotationy_ = 0;
  rotationz_ = 0;
  opacity_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AETransform::~AETransform() {
  SharedDtor();
}

void AETransform::SharedDtor() {
  if (this != default_instance_) {
    delete anchorpoint_;
    delete scale_;
    delete position_;
    delete orientation_;
  }
}

void AETransform::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AETransform::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AETransform_descriptor_;
}

const AETransform& AETransform::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AETransform* AETransform::default_instance_ = NULL;

AETransform* AETransform::New() const {
  return new AETransform;
}

void AETransform::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_anchorpoint()) {
      if (anchorpoint_ != NULL) anchorpoint_->::aefilter::AEVector::Clear();
    }
    if (has_scale()) {
      if (scale_ != NULL) scale_->::aefilter::AEVector::Clear();
    }
    if (has_position()) {
      if (position_ != NULL) position_->::aefilter::AEVector::Clear();
    }
    if (has_orientation()) {
      if (orientation_ != NULL) orientation_->::aefilter::AEVector::Clear();
    }
    rotationx_ = 0;
    rotationy_ = 0;
    rotationz_ = 0;
    opacity_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AETransform::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .aefilter.AEVector anchorPoint = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_anchorpoint()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_scale;
        break;
      }
      
      // required .aefilter.AEVector scale = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_scale:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scale()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_position;
        break;
      }
      
      // required .aefilter.AEVector position = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_orientation;
        break;
      }
      
      // required .aefilter.AEVector orientation = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_orientation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_orientation()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_rotationX;
        break;
      }
      
      // required float rotationX = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rotationX:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rotationx_)));
          set_has_rotationx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_rotationY;
        break;
      }
      
      // required float rotationY = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rotationY:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rotationy_)));
          set_has_rotationy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_rotationZ;
        break;
      }
      
      // required float rotationZ = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rotationZ:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rotationz_)));
          set_has_rotationz();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_opacity;
        break;
      }
      
      // required float opacity = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_opacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &opacity_)));
          set_has_opacity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AETransform::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .aefilter.AEVector anchorPoint = 1;
  if (has_anchorpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->anchorpoint(), output);
  }
  
  // required .aefilter.AEVector scale = 2;
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->scale(), output);
  }
  
  // required .aefilter.AEVector position = 3;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->position(), output);
  }
  
  // required .aefilter.AEVector orientation = 4;
  if (has_orientation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->orientation(), output);
  }
  
  // required float rotationX = 5;
  if (has_rotationx()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->rotationx(), output);
  }
  
  // required float rotationY = 6;
  if (has_rotationy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->rotationy(), output);
  }
  
  // required float rotationZ = 7;
  if (has_rotationz()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->rotationz(), output);
  }
  
  // required float opacity = 8;
  if (has_opacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->opacity(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AETransform::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .aefilter.AEVector anchorPoint = 1;
  if (has_anchorpoint()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->anchorpoint(), target);
  }
  
  // required .aefilter.AEVector scale = 2;
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->scale(), target);
  }
  
  // required .aefilter.AEVector position = 3;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->position(), target);
  }
  
  // required .aefilter.AEVector orientation = 4;
  if (has_orientation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->orientation(), target);
  }
  
  // required float rotationX = 5;
  if (has_rotationx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->rotationx(), target);
  }
  
  // required float rotationY = 6;
  if (has_rotationy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->rotationy(), target);
  }
  
  // required float rotationZ = 7;
  if (has_rotationz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->rotationz(), target);
  }
  
  // required float opacity = 8;
  if (has_opacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->opacity(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AETransform::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .aefilter.AEVector anchorPoint = 1;
    if (has_anchorpoint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->anchorpoint());
    }
    
    // required .aefilter.AEVector scale = 2;
    if (has_scale()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->scale());
    }
    
    // required .aefilter.AEVector position = 3;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position());
    }
    
    // required .aefilter.AEVector orientation = 4;
    if (has_orientation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->orientation());
    }
    
    // required float rotationX = 5;
    if (has_rotationx()) {
      total_size += 1 + 4;
    }
    
    // required float rotationY = 6;
    if (has_rotationy()) {
      total_size += 1 + 4;
    }
    
    // required float rotationZ = 7;
    if (has_rotationz()) {
      total_size += 1 + 4;
    }
    
    // required float opacity = 8;
    if (has_opacity()) {
      total_size += 1 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AETransform::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AETransform* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AETransform*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AETransform::MergeFrom(const AETransform& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_anchorpoint()) {
      mutable_anchorpoint()->::aefilter::AEVector::MergeFrom(from.anchorpoint());
    }
    if (from.has_scale()) {
      mutable_scale()->::aefilter::AEVector::MergeFrom(from.scale());
    }
    if (from.has_position()) {
      mutable_position()->::aefilter::AEVector::MergeFrom(from.position());
    }
    if (from.has_orientation()) {
      mutable_orientation()->::aefilter::AEVector::MergeFrom(from.orientation());
    }
    if (from.has_rotationx()) {
      set_rotationx(from.rotationx());
    }
    if (from.has_rotationy()) {
      set_rotationy(from.rotationy());
    }
    if (from.has_rotationz()) {
      set_rotationz(from.rotationz());
    }
    if (from.has_opacity()) {
      set_opacity(from.opacity());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AETransform::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AETransform::CopyFrom(const AETransform& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AETransform::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;
  
  if (has_anchorpoint()) {
    if (!this->anchorpoint().IsInitialized()) return false;
  }
  if (has_scale()) {
    if (!this->scale().IsInitialized()) return false;
  }
  if (has_position()) {
    if (!this->position().IsInitialized()) return false;
  }
  if (has_orientation()) {
    if (!this->orientation().IsInitialized()) return false;
  }
  return true;
}

void AETransform::Swap(AETransform* other) {
  if (other != this) {
    std::swap(anchorpoint_, other->anchorpoint_);
    std::swap(scale_, other->scale_);
    std::swap(position_, other->position_);
    std::swap(orientation_, other->orientation_);
    std::swap(rotationx_, other->rotationx_);
    std::swap(rotationy_, other->rotationy_);
    std::swap(rotationz_, other->rotationz_);
    std::swap(opacity_, other->opacity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AETransform::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AETransform_descriptor_;
  metadata.reflection = AETransform_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AEKeyPair::kKeyFieldNumber;
const int AEKeyPair::kValueFieldNumber;
#endif  // !_MSC_VER

AEKeyPair::AEKeyPair()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AEKeyPair::InitAsDefaultInstance() {
}

AEKeyPair::AEKeyPair(const AEKeyPair& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AEKeyPair::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AEKeyPair::~AEKeyPair() {
  SharedDtor();
}

void AEKeyPair::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void AEKeyPair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AEKeyPair::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEKeyPair_descriptor_;
}

const AEKeyPair& AEKeyPair::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AEKeyPair* AEKeyPair::default_instance_ = NULL;

AEKeyPair* AEKeyPair::New() const {
  return new AEKeyPair;
}

void AEKeyPair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::kEmptyString) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AEKeyPair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }
      
      // required string value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AEKeyPair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }
  
  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->value(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AEKeyPair::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }
  
  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AEKeyPair::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }
    
    // required string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AEKeyPair::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AEKeyPair* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AEKeyPair*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AEKeyPair::MergeFrom(const AEKeyPair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AEKeyPair::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AEKeyPair::CopyFrom(const AEKeyPair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AEKeyPair::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void AEKeyPair::Swap(AEKeyPair* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AEKeyPair::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AEKeyPair_descriptor_;
  metadata.reflection = AEKeyPair_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AETextInfo::kJustificationFieldNumber;
const int AETextInfo::kFontSizeFieldNumber;
const int AETextInfo::kFontColorFieldNumber;
const int AETextInfo::kFontNameFieldNumber;
const int AETextInfo::kIsPointTextFieldNumber;
const int AETextInfo::kBoundsWidthFieldNumber;
const int AETextInfo::kBoundsHeightFieldNumber;
const int AETextInfo::kIsLabelFieldNumber;
const int AETextInfo::kTextFieldNumber;
const int AETextInfo::kMultilineFieldNumber;
const int AETextInfo::kEllipsisFieldNumber;
const int AETextInfo::kLeadingFieldNumber;
const int AETextInfo::kIsAllCapsFieldNumber;
#endif  // !_MSC_VER

AETextInfo::AETextInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AETextInfo::InitAsDefaultInstance() {
  fontcolor_ = const_cast< ::aefilter::AEColor*>(&::aefilter::AEColor::default_instance());
}

AETextInfo::AETextInfo(const AETextInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AETextInfo::SharedCtor() {
  _cached_size_ = 0;
  justification_ = -1;
  fontsize_ = 0;
  fontcolor_ = NULL;
  fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ispointtext_ = false;
  boundswidth_ = 0;
  boundsheight_ = 0;
  islabel_ = false;
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  multiline_ = false;
  ellipsis_ = false;
  leading_ = 0u;
  isallcaps_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AETextInfo::~AETextInfo() {
  SharedDtor();
}

void AETextInfo::SharedDtor() {
  if (fontname_ != &::google::protobuf::internal::kEmptyString) {
    delete fontname_;
  }
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (this != default_instance_) {
    delete fontcolor_;
  }
}

void AETextInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AETextInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AETextInfo_descriptor_;
}

const AETextInfo& AETextInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AETextInfo* AETextInfo::default_instance_ = NULL;

AETextInfo* AETextInfo::New() const {
  return new AETextInfo;
}

void AETextInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    justification_ = -1;
    fontsize_ = 0;
    if (has_fontcolor()) {
      if (fontcolor_ != NULL) fontcolor_->::aefilter::AEColor::Clear();
    }
    if (has_fontname()) {
      if (fontname_ != &::google::protobuf::internal::kEmptyString) {
        fontname_->clear();
      }
    }
    ispointtext_ = false;
    boundswidth_ = 0;
    boundsheight_ = 0;
    islabel_ = false;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
    multiline_ = false;
    ellipsis_ = false;
    leading_ = 0u;
    isallcaps_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AETextInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .aefilter.AEJustificationType justification = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (aefilter::AEJustificationType_IsValid(value)) {
            set_justification(static_cast< aefilter::AEJustificationType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_fontSize;
        break;
      }
      
      // required int32 fontSize = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fontSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fontsize_)));
          set_has_fontsize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_fontColor;
        break;
      }
      
      // required .aefilter.AEColor fontColor = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fontColor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fontcolor()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_fontName;
        break;
      }
      
      // required string fontName = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fontName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fontname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->fontname().data(), this->fontname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_isPointText;
        break;
      }
      
      // required bool isPointText = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isPointText:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ispointtext_)));
          set_has_ispointtext();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_boundsWidth;
        break;
      }
      
      // optional int32 boundsWidth = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_boundsWidth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &boundswidth_)));
          set_has_boundswidth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_boundsHeight;
        break;
      }
      
      // optional int32 boundsHeight = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_boundsHeight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &boundsheight_)));
          set_has_boundsheight();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_isLabel;
        break;
      }
      
      // optional bool isLabel = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isLabel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &islabel_)));
          set_has_islabel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_text;
        break;
      }
      
      // optional string text = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_multiline;
        break;
      }
      
      // optional bool multiline = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_multiline:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &multiline_)));
          set_has_multiline();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_ellipsis;
        break;
      }
      
      // optional bool ellipsis = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ellipsis:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ellipsis_)));
          set_has_ellipsis();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_leading;
        break;
      }
      
      // optional uint32 leading = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_leading:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &leading_)));
          set_has_leading();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_isAllCaps;
        break;
      }
      
      // optional bool isAllCaps = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isAllCaps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isallcaps_)));
          set_has_isallcaps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AETextInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .aefilter.AEJustificationType justification = 1;
  if (has_justification()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->justification(), output);
  }
  
  // required int32 fontSize = 2;
  if (has_fontsize()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->fontsize(), output);
  }
  
  // required .aefilter.AEColor fontColor = 3;
  if (has_fontcolor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->fontcolor(), output);
  }
  
  // required string fontName = 4;
  if (has_fontname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->fontname().data(), this->fontname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->fontname(), output);
  }
  
  // required bool isPointText = 5;
  if (has_ispointtext()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->ispointtext(), output);
  }
  
  // optional int32 boundsWidth = 6;
  if (has_boundswidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->boundswidth(), output);
  }
  
  // optional int32 boundsHeight = 7;
  if (has_boundsheight()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->boundsheight(), output);
  }
  
  // optional bool isLabel = 8;
  if (has_islabel()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->islabel(), output);
  }
  
  // optional string text = 9;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->text(), output);
  }
  
  // optional bool multiline = 10;
  if (has_multiline()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->multiline(), output);
  }
  
  // optional bool ellipsis = 11;
  if (has_ellipsis()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->ellipsis(), output);
  }
  
  // optional uint32 leading = 12;
  if (has_leading()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->leading(), output);
  }
  
  // optional bool isAllCaps = 13;
  if (has_isallcaps()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->isallcaps(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AETextInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .aefilter.AEJustificationType justification = 1;
  if (has_justification()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->justification(), target);
  }
  
  // required int32 fontSize = 2;
  if (has_fontsize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->fontsize(), target);
  }
  
  // required .aefilter.AEColor fontColor = 3;
  if (has_fontcolor()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->fontcolor(), target);
  }
  
  // required string fontName = 4;
  if (has_fontname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->fontname().data(), this->fontname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->fontname(), target);
  }
  
  // required bool isPointText = 5;
  if (has_ispointtext()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->ispointtext(), target);
  }
  
  // optional int32 boundsWidth = 6;
  if (has_boundswidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->boundswidth(), target);
  }
  
  // optional int32 boundsHeight = 7;
  if (has_boundsheight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->boundsheight(), target);
  }
  
  // optional bool isLabel = 8;
  if (has_islabel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->islabel(), target);
  }
  
  // optional string text = 9;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->text(), target);
  }
  
  // optional bool multiline = 10;
  if (has_multiline()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->multiline(), target);
  }
  
  // optional bool ellipsis = 11;
  if (has_ellipsis()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->ellipsis(), target);
  }
  
  // optional uint32 leading = 12;
  if (has_leading()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->leading(), target);
  }
  
  // optional bool isAllCaps = 13;
  if (has_isallcaps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->isallcaps(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AETextInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .aefilter.AEJustificationType justification = 1;
    if (has_justification()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->justification());
    }
    
    // required int32 fontSize = 2;
    if (has_fontsize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fontsize());
    }
    
    // required .aefilter.AEColor fontColor = 3;
    if (has_fontcolor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fontcolor());
    }
    
    // required string fontName = 4;
    if (has_fontname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fontname());
    }
    
    // required bool isPointText = 5;
    if (has_ispointtext()) {
      total_size += 1 + 1;
    }
    
    // optional int32 boundsWidth = 6;
    if (has_boundswidth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->boundswidth());
    }
    
    // optional int32 boundsHeight = 7;
    if (has_boundsheight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->boundsheight());
    }
    
    // optional bool isLabel = 8;
    if (has_islabel()) {
      total_size += 1 + 1;
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string text = 9;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }
    
    // optional bool multiline = 10;
    if (has_multiline()) {
      total_size += 1 + 1;
    }
    
    // optional bool ellipsis = 11;
    if (has_ellipsis()) {
      total_size += 1 + 1;
    }
    
    // optional uint32 leading = 12;
    if (has_leading()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->leading());
    }
    
    // optional bool isAllCaps = 13;
    if (has_isallcaps()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AETextInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AETextInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AETextInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AETextInfo::MergeFrom(const AETextInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_justification()) {
      set_justification(from.justification());
    }
    if (from.has_fontsize()) {
      set_fontsize(from.fontsize());
    }
    if (from.has_fontcolor()) {
      mutable_fontcolor()->::aefilter::AEColor::MergeFrom(from.fontcolor());
    }
    if (from.has_fontname()) {
      set_fontname(from.fontname());
    }
    if (from.has_ispointtext()) {
      set_ispointtext(from.ispointtext());
    }
    if (from.has_boundswidth()) {
      set_boundswidth(from.boundswidth());
    }
    if (from.has_boundsheight()) {
      set_boundsheight(from.boundsheight());
    }
    if (from.has_islabel()) {
      set_islabel(from.islabel());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_text()) {
      set_text(from.text());
    }
    if (from.has_multiline()) {
      set_multiline(from.multiline());
    }
    if (from.has_ellipsis()) {
      set_ellipsis(from.ellipsis());
    }
    if (from.has_leading()) {
      set_leading(from.leading());
    }
    if (from.has_isallcaps()) {
      set_isallcaps(from.isallcaps());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AETextInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AETextInfo::CopyFrom(const AETextInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AETextInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  if (has_fontcolor()) {
    if (!this->fontcolor().IsInitialized()) return false;
  }
  return true;
}

void AETextInfo::Swap(AETextInfo* other) {
  if (other != this) {
    std::swap(justification_, other->justification_);
    std::swap(fontsize_, other->fontsize_);
    std::swap(fontcolor_, other->fontcolor_);
    std::swap(fontname_, other->fontname_);
    std::swap(ispointtext_, other->ispointtext_);
    std::swap(boundswidth_, other->boundswidth_);
    std::swap(boundsheight_, other->boundsheight_);
    std::swap(islabel_, other->islabel_);
    std::swap(text_, other->text_);
    std::swap(multiline_, other->multiline_);
    std::swap(ellipsis_, other->ellipsis_);
    std::swap(leading_, other->leading_);
    std::swap(isallcaps_, other->isallcaps_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AETextInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AETextInfo_descriptor_;
  metadata.reflection = AETextInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AEMaskVertex::kXFieldNumber;
const int AEMaskVertex::kYFieldNumber;
const int AEMaskVertex::kTanInXFieldNumber;
const int AEMaskVertex::kTanInYFieldNumber;
const int AEMaskVertex::kTanOutXFieldNumber;
const int AEMaskVertex::kTanOutYFieldNumber;
#endif  // !_MSC_VER

AEMaskVertex::AEMaskVertex()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AEMaskVertex::InitAsDefaultInstance() {
}

AEMaskVertex::AEMaskVertex(const AEMaskVertex& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AEMaskVertex::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  tan_in_x_ = 0;
  tan_in_y_ = 0;
  tan_out_x_ = 0;
  tan_out_y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AEMaskVertex::~AEMaskVertex() {
  SharedDtor();
}

void AEMaskVertex::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AEMaskVertex::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AEMaskVertex::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEMaskVertex_descriptor_;
}

const AEMaskVertex& AEMaskVertex::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AEMaskVertex* AEMaskVertex::default_instance_ = NULL;

AEMaskVertex* AEMaskVertex::New() const {
  return new AEMaskVertex;
}

void AEMaskVertex::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    tan_in_x_ = 0;
    tan_in_y_ = 0;
    tan_out_x_ = 0;
    tan_out_y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AEMaskVertex::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }
      
      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_tan_in_x;
        break;
      }
      
      // required float tan_in_x = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_tan_in_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &tan_in_x_)));
          set_has_tan_in_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_tan_in_y;
        break;
      }
      
      // required float tan_in_y = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_tan_in_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &tan_in_y_)));
          set_has_tan_in_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_tan_out_x;
        break;
      }
      
      // required float tan_out_x = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_tan_out_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &tan_out_x_)));
          set_has_tan_out_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_tan_out_y;
        break;
      }
      
      // required float tan_out_y = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_tan_out_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &tan_out_y_)));
          set_has_tan_out_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AEMaskVertex::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }
  
  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }
  
  // required float tan_in_x = 3;
  if (has_tan_in_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->tan_in_x(), output);
  }
  
  // required float tan_in_y = 4;
  if (has_tan_in_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->tan_in_y(), output);
  }
  
  // required float tan_out_x = 5;
  if (has_tan_out_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->tan_out_x(), output);
  }
  
  // required float tan_out_y = 6;
  if (has_tan_out_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->tan_out_y(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AEMaskVertex::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }
  
  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }
  
  // required float tan_in_x = 3;
  if (has_tan_in_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->tan_in_x(), target);
  }
  
  // required float tan_in_y = 4;
  if (has_tan_in_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->tan_in_y(), target);
  }
  
  // required float tan_out_x = 5;
  if (has_tan_out_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->tan_out_x(), target);
  }
  
  // required float tan_out_y = 6;
  if (has_tan_out_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->tan_out_y(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AEMaskVertex::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }
    
    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }
    
    // required float tan_in_x = 3;
    if (has_tan_in_x()) {
      total_size += 1 + 4;
    }
    
    // required float tan_in_y = 4;
    if (has_tan_in_y()) {
      total_size += 1 + 4;
    }
    
    // required float tan_out_x = 5;
    if (has_tan_out_x()) {
      total_size += 1 + 4;
    }
    
    // required float tan_out_y = 6;
    if (has_tan_out_y()) {
      total_size += 1 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AEMaskVertex::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AEMaskVertex* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AEMaskVertex*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AEMaskVertex::MergeFrom(const AEMaskVertex& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_tan_in_x()) {
      set_tan_in_x(from.tan_in_x());
    }
    if (from.has_tan_in_y()) {
      set_tan_in_y(from.tan_in_y());
    }
    if (from.has_tan_out_x()) {
      set_tan_out_x(from.tan_out_x());
    }
    if (from.has_tan_out_y()) {
      set_tan_out_y(from.tan_out_y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AEMaskVertex::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AEMaskVertex::CopyFrom(const AEMaskVertex& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AEMaskVertex::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  
  return true;
}

void AEMaskVertex::Swap(AEMaskVertex* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(tan_in_x_, other->tan_in_x_);
    std::swap(tan_in_y_, other->tan_in_y_);
    std::swap(tan_out_x_, other->tan_out_x_);
    std::swap(tan_out_y_, other->tan_out_y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AEMaskVertex::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AEMaskVertex_descriptor_;
  metadata.reflection = AEMaskVertex_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AEMask::kIsClosedFieldNumber;
const int AEMask::kMaskSourceIdFieldNumber;
#endif  // !_MSC_VER

AEMask::AEMask()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AEMask::InitAsDefaultInstance() {
}

AEMask::AEMask(const AEMask& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AEMask::SharedCtor() {
  _cached_size_ = 0;
  is_closed_ = false;
  mask_source_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AEMask::~AEMask() {
  SharedDtor();
}

void AEMask::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AEMask::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AEMask::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEMask_descriptor_;
}

const AEMask& AEMask::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AEMask* AEMask::default_instance_ = NULL;

AEMask* AEMask::New() const {
  return new AEMask;
}

void AEMask::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    is_closed_ = false;
    mask_source_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AEMask::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool is_closed = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_closed_)));
          set_has_is_closed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_mask_source_id;
        break;
      }
      
      // required int32 mask_source_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mask_source_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mask_source_id_)));
          set_has_mask_source_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AEMask::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool is_closed = 1;
  if (has_is_closed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->is_closed(), output);
  }
  
  // required int32 mask_source_id = 2;
  if (has_mask_source_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->mask_source_id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AEMask::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool is_closed = 1;
  if (has_is_closed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->is_closed(), target);
  }
  
  // required int32 mask_source_id = 2;
  if (has_mask_source_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->mask_source_id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AEMask::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool is_closed = 1;
    if (has_is_closed()) {
      total_size += 1 + 1;
    }
    
    // required int32 mask_source_id = 2;
    if (has_mask_source_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mask_source_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AEMask::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AEMask* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AEMask*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AEMask::MergeFrom(const AEMask& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_is_closed()) {
      set_is_closed(from.is_closed());
    }
    if (from.has_mask_source_id()) {
      set_mask_source_id(from.mask_source_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AEMask::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AEMask::CopyFrom(const AEMask& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AEMask::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void AEMask::Swap(AEMask* other) {
  if (other != this) {
    std::swap(is_closed_, other->is_closed_);
    std::swap(mask_source_id_, other->mask_source_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AEMask::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AEMask_descriptor_;
  metadata.reflection = AEMask_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AEEffectParam::kNameFieldNumber;
const int AEEffectParam::kFvalue1FieldNumber;
const int AEEffectParam::kFvalue2FieldNumber;
const int AEEffectParam::kFvalue3FieldNumber;
#endif  // !_MSC_VER

AEEffectParam::AEEffectParam()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AEEffectParam::InitAsDefaultInstance() {
}

AEEffectParam::AEEffectParam(const AEEffectParam& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AEEffectParam::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fvalue1_ = 0;
  fvalue2_ = 0;
  fvalue3_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AEEffectParam::~AEEffectParam() {
  SharedDtor();
}

void AEEffectParam::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void AEEffectParam::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AEEffectParam::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEEffectParam_descriptor_;
}

const AEEffectParam& AEEffectParam::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AEEffectParam* AEEffectParam::default_instance_ = NULL;

AEEffectParam* AEEffectParam::New() const {
  return new AEEffectParam;
}

void AEEffectParam::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    fvalue1_ = 0;
    fvalue2_ = 0;
    fvalue3_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AEEffectParam::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_fvalue1;
        break;
      }
      
      // optional float fvalue1 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_fvalue1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fvalue1_)));
          set_has_fvalue1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_fvalue2;
        break;
      }
      
      // optional float fvalue2 = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_fvalue2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fvalue2_)));
          set_has_fvalue2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_fvalue3;
        break;
      }
      
      // optional float fvalue3 = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_fvalue3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fvalue3_)));
          set_has_fvalue3();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AEEffectParam::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional float fvalue1 = 2;
  if (has_fvalue1()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->fvalue1(), output);
  }
  
  // optional float fvalue2 = 3;
  if (has_fvalue2()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->fvalue2(), output);
  }
  
  // optional float fvalue3 = 4;
  if (has_fvalue3()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->fvalue3(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AEEffectParam::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // optional float fvalue1 = 2;
  if (has_fvalue1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->fvalue1(), target);
  }
  
  // optional float fvalue2 = 3;
  if (has_fvalue2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->fvalue2(), target);
  }
  
  // optional float fvalue3 = 4;
  if (has_fvalue3()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->fvalue3(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AEEffectParam::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional float fvalue1 = 2;
    if (has_fvalue1()) {
      total_size += 1 + 4;
    }
    
    // optional float fvalue2 = 3;
    if (has_fvalue2()) {
      total_size += 1 + 4;
    }
    
    // optional float fvalue3 = 4;
    if (has_fvalue3()) {
      total_size += 1 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AEEffectParam::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AEEffectParam* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AEEffectParam*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AEEffectParam::MergeFrom(const AEEffectParam& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_fvalue1()) {
      set_fvalue1(from.fvalue1());
    }
    if (from.has_fvalue2()) {
      set_fvalue2(from.fvalue2());
    }
    if (from.has_fvalue3()) {
      set_fvalue3(from.fvalue3());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AEEffectParam::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AEEffectParam::CopyFrom(const AEEffectParam& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AEEffectParam::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void AEEffectParam::Swap(AEEffectParam* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(fvalue1_, other->fvalue1_);
    std::swap(fvalue2_, other->fvalue2_);
    std::swap(fvalue3_, other->fvalue3_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AEEffectParam::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AEEffectParam_descriptor_;
  metadata.reflection = AEEffectParam_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AEEffect::kParamFieldNumber;
#endif  // !_MSC_VER

AEEffect::AEEffect()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AEEffect::InitAsDefaultInstance() {
}

AEEffect::AEEffect(const AEEffect& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AEEffect::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AEEffect::~AEEffect() {
  SharedDtor();
}

void AEEffect::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AEEffect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AEEffect::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEEffect_descriptor_;
}

const AEEffect& AEEffect::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AEEffect* AEEffect::default_instance_ = NULL;

AEEffect* AEEffect::New() const {
  return new AEEffect;
}

void AEEffect::Clear() {
  param_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AEEffect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .aefilter.AEEffectParam param = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_param:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_param()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_param;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AEEffect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .aefilter.AEEffectParam param = 1;
  for (int i = 0; i < this->param_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->param(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AEEffect::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .aefilter.AEEffectParam param = 1;
  for (int i = 0; i < this->param_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->param(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AEEffect::ByteSize() const {
  int total_size = 0;
  
  // repeated .aefilter.AEEffectParam param = 1;
  total_size += 1 * this->param_size();
  for (int i = 0; i < this->param_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->param(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AEEffect::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AEEffect* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AEEffect*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AEEffect::MergeFrom(const AEEffect& from) {
  GOOGLE_CHECK_NE(&from, this);
  param_.MergeFrom(from.param_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AEEffect::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AEEffect::CopyFrom(const AEEffect& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AEEffect::IsInitialized() const {
  
  for (int i = 0; i < param_size(); i++) {
    if (!this->param(i).IsInitialized()) return false;
  }
  return true;
}

void AEEffect::Swap(AEEffect* other) {
  if (other != this) {
    param_.Swap(&other->param_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AEEffect::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AEEffect_descriptor_;
  metadata.reflection = AEEffect_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AELayer::kNameFieldNumber;
const int AELayer::kIdFieldNumber;
const int AELayer::kSourceidFieldNumber;
const int AELayer::kTransformFieldNumber;
const int AELayer::kAcceptsshadowsFieldNumber;
const int AELayer::kAcceptslightsFieldNumber;
const int AELayer::kCastsshadowsFieldNumber;
const int AELayer::kIshiddenFieldNumber;
const int AELayer::kTextinfoFieldNumber;
const int AELayer::kParentidFieldNumber;
const int AELayer::kMaskFieldNumber;
const int AELayer::kEffectFieldNumber;
const int AELayer::kClassnameFieldNumber;
const int AELayer::kPropertiesFieldNumber;
#endif  // !_MSC_VER

AELayer::AELayer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AELayer::InitAsDefaultInstance() {
  transform_ = const_cast< ::aefilter::AETransform*>(&::aefilter::AETransform::default_instance());
  textinfo_ = const_cast< ::aefilter::AETextInfo*>(&::aefilter::AETextInfo::default_instance());
}

AELayer::AELayer(const AELayer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AELayer::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  id_ = 0;
  sourceid_ = 0;
  transform_ = NULL;
  acceptsshadows_ = false;
  acceptslights_ = false;
  castsshadows_ = false;
  ishidden_ = false;
  textinfo_ = NULL;
  parentid_ = 0;
  classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AELayer::~AELayer() {
  SharedDtor();
}

void AELayer::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (this != default_instance_) {
    delete transform_;
    delete textinfo_;
  }
}

void AELayer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AELayer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AELayer_descriptor_;
}

const AELayer& AELayer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AELayer* AELayer::default_instance_ = NULL;

AELayer* AELayer::New() const {
  return new AELayer;
}

void AELayer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    id_ = 0;
    sourceid_ = 0;
    if (has_transform()) {
      if (transform_ != NULL) transform_->::aefilter::AETransform::Clear();
    }
    acceptsshadows_ = false;
    acceptslights_ = false;
    castsshadows_ = false;
    ishidden_ = false;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_textinfo()) {
      if (textinfo_ != NULL) textinfo_->::aefilter::AETextInfo::Clear();
    }
    parentid_ = 0;
    if (has_classname()) {
      if (classname_ != &::google::protobuf::internal::kEmptyString) {
        classname_->clear();
      }
    }
  }
  mask_.Clear();
  effect_.Clear();
  properties_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AELayer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_id;
        break;
      }
      
      // required int32 id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_sourceid;
        break;
      }
      
      // required int32 sourceid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sourceid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sourceid_)));
          set_has_sourceid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_transform;
        break;
      }
      
      // required .aefilter.AETransform transform = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transform:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transform()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_acceptsshadows;
        break;
      }
      
      // required bool acceptsshadows = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_acceptsshadows:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &acceptsshadows_)));
          set_has_acceptsshadows();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_acceptslights;
        break;
      }
      
      // required bool acceptslights = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_acceptslights:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &acceptslights_)));
          set_has_acceptslights();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_castsshadows;
        break;
      }
      
      // required bool castsshadows = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_castsshadows:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &castsshadows_)));
          set_has_castsshadows();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_ishidden;
        break;
      }
      
      // optional bool ishidden = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ishidden:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ishidden_)));
          set_has_ishidden();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_textinfo;
        break;
      }
      
      // optional .aefilter.AETextInfo textinfo = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_textinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_textinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_parentid;
        break;
      }
      
      // optional int32 parentid = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_parentid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &parentid_)));
          set_has_parentid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_mask;
        break;
      }
      
      // repeated .aefilter.AEMask mask = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mask:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_mask()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_mask;
        if (input->ExpectTag(106)) goto parse_effect;
        break;
      }
      
      // repeated .aefilter.AEEffect effect = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_effect:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_effect()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_effect;
        if (input->ExpectTag(114)) goto parse_classname;
        break;
      }
      
      // optional string classname = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_classname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_classname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->classname().data(), this->classname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_properties;
        break;
      }
      
      // repeated .aefilter.AEKeyPair properties = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_properties:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_properties()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_properties;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AELayer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required int32 id = 3;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->id(), output);
  }
  
  // required int32 sourceid = 4;
  if (has_sourceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->sourceid(), output);
  }
  
  // required .aefilter.AETransform transform = 5;
  if (has_transform()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->transform(), output);
  }
  
  // required bool acceptsshadows = 6;
  if (has_acceptsshadows()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->acceptsshadows(), output);
  }
  
  // required bool acceptslights = 7;
  if (has_acceptslights()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->acceptslights(), output);
  }
  
  // required bool castsshadows = 8;
  if (has_castsshadows()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->castsshadows(), output);
  }
  
  // optional bool ishidden = 9;
  if (has_ishidden()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->ishidden(), output);
  }
  
  // optional .aefilter.AETextInfo textinfo = 10;
  if (has_textinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->textinfo(), output);
  }
  
  // optional int32 parentid = 11;
  if (has_parentid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->parentid(), output);
  }
  
  // repeated .aefilter.AEMask mask = 12;
  for (int i = 0; i < this->mask_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->mask(i), output);
  }
  
  // repeated .aefilter.AEEffect effect = 13;
  for (int i = 0; i < this->effect_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->effect(i), output);
  }
  
  // optional string classname = 14;
  if (has_classname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->classname().data(), this->classname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->classname(), output);
  }
  
  // repeated .aefilter.AEKeyPair properties = 15;
  for (int i = 0; i < this->properties_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, this->properties(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AELayer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required int32 id = 3;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->id(), target);
  }
  
  // required int32 sourceid = 4;
  if (has_sourceid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->sourceid(), target);
  }
  
  // required .aefilter.AETransform transform = 5;
  if (has_transform()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->transform(), target);
  }
  
  // required bool acceptsshadows = 6;
  if (has_acceptsshadows()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->acceptsshadows(), target);
  }
  
  // required bool acceptslights = 7;
  if (has_acceptslights()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->acceptslights(), target);
  }
  
  // required bool castsshadows = 8;
  if (has_castsshadows()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->castsshadows(), target);
  }
  
  // optional bool ishidden = 9;
  if (has_ishidden()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->ishidden(), target);
  }
  
  // optional .aefilter.AETextInfo textinfo = 10;
  if (has_textinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->textinfo(), target);
  }
  
  // optional int32 parentid = 11;
  if (has_parentid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->parentid(), target);
  }
  
  // repeated .aefilter.AEMask mask = 12;
  for (int i = 0; i < this->mask_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->mask(i), target);
  }
  
  // repeated .aefilter.AEEffect effect = 13;
  for (int i = 0; i < this->effect_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->effect(i), target);
  }
  
  // optional string classname = 14;
  if (has_classname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->classname().data(), this->classname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->classname(), target);
  }
  
  // repeated .aefilter.AEKeyPair properties = 15;
  for (int i = 0; i < this->properties_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, this->properties(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AELayer::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required int32 id = 3;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // required int32 sourceid = 4;
    if (has_sourceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sourceid());
    }
    
    // required .aefilter.AETransform transform = 5;
    if (has_transform()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transform());
    }
    
    // required bool acceptsshadows = 6;
    if (has_acceptsshadows()) {
      total_size += 1 + 1;
    }
    
    // required bool acceptslights = 7;
    if (has_acceptslights()) {
      total_size += 1 + 1;
    }
    
    // required bool castsshadows = 8;
    if (has_castsshadows()) {
      total_size += 1 + 1;
    }
    
    // optional bool ishidden = 9;
    if (has_ishidden()) {
      total_size += 1 + 1;
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .aefilter.AETextInfo textinfo = 10;
    if (has_textinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->textinfo());
    }
    
    // optional int32 parentid = 11;
    if (has_parentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->parentid());
    }
    
    // optional string classname = 14;
    if (has_classname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->classname());
    }
    
  }
  // repeated .aefilter.AEMask mask = 12;
  total_size += 1 * this->mask_size();
  for (int i = 0; i < this->mask_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mask(i));
  }
  
  // repeated .aefilter.AEEffect effect = 13;
  total_size += 1 * this->effect_size();
  for (int i = 0; i < this->effect_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->effect(i));
  }
  
  // repeated .aefilter.AEKeyPair properties = 15;
  total_size += 1 * this->properties_size();
  for (int i = 0; i < this->properties_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->properties(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AELayer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AELayer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AELayer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AELayer::MergeFrom(const AELayer& from) {
  GOOGLE_CHECK_NE(&from, this);
  mask_.MergeFrom(from.mask_);
  effect_.MergeFrom(from.effect_);
  properties_.MergeFrom(from.properties_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_sourceid()) {
      set_sourceid(from.sourceid());
    }
    if (from.has_transform()) {
      mutable_transform()->::aefilter::AETransform::MergeFrom(from.transform());
    }
    if (from.has_acceptsshadows()) {
      set_acceptsshadows(from.acceptsshadows());
    }
    if (from.has_acceptslights()) {
      set_acceptslights(from.acceptslights());
    }
    if (from.has_castsshadows()) {
      set_castsshadows(from.castsshadows());
    }
    if (from.has_ishidden()) {
      set_ishidden(from.ishidden());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_textinfo()) {
      mutable_textinfo()->::aefilter::AETextInfo::MergeFrom(from.textinfo());
    }
    if (from.has_parentid()) {
      set_parentid(from.parentid());
    }
    if (from.has_classname()) {
      set_classname(from.classname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AELayer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AELayer::CopyFrom(const AELayer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AELayer::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;
  
  if (has_transform()) {
    if (!this->transform().IsInitialized()) return false;
  }
  if (has_textinfo()) {
    if (!this->textinfo().IsInitialized()) return false;
  }
  for (int i = 0; i < mask_size(); i++) {
    if (!this->mask(i).IsInitialized()) return false;
  }
  for (int i = 0; i < effect_size(); i++) {
    if (!this->effect(i).IsInitialized()) return false;
  }
  for (int i = 0; i < properties_size(); i++) {
    if (!this->properties(i).IsInitialized()) return false;
  }
  return true;
}

void AELayer::Swap(AELayer* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(id_, other->id_);
    std::swap(sourceid_, other->sourceid_);
    std::swap(transform_, other->transform_);
    std::swap(acceptsshadows_, other->acceptsshadows_);
    std::swap(acceptslights_, other->acceptslights_);
    std::swap(castsshadows_, other->castsshadows_);
    std::swap(ishidden_, other->ishidden_);
    std::swap(textinfo_, other->textinfo_);
    std::swap(parentid_, other->parentid_);
    mask_.Swap(&other->mask_);
    effect_.Swap(&other->effect_);
    std::swap(classname_, other->classname_);
    properties_.Swap(&other->properties_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AELayer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AELayer_descriptor_;
  metadata.reflection = AELayer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AECamera::kNameFieldNumber;
const int AECamera::kTransformFieldNumber;
const int AECamera::kFOVFieldNumber;
const int AECamera::kIdFieldNumber;
const int AECamera::kPropertiesFieldNumber;
const int AECamera::kParentidFieldNumber;
#endif  // !_MSC_VER

AECamera::AECamera()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AECamera::InitAsDefaultInstance() {
  transform_ = const_cast< ::aefilter::AETransform*>(&::aefilter::AETransform::default_instance());
}

AECamera::AECamera(const AECamera& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AECamera::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  transform_ = NULL;
  fov_ = 0;
  id_ = 0;
  parentid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AECamera::~AECamera() {
  SharedDtor();
}

void AECamera::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete transform_;
  }
}

void AECamera::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AECamera::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AECamera_descriptor_;
}

const AECamera& AECamera::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AECamera* AECamera::default_instance_ = NULL;

AECamera* AECamera::New() const {
  return new AECamera;
}

void AECamera::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_transform()) {
      if (transform_ != NULL) transform_->::aefilter::AETransform::Clear();
    }
    fov_ = 0;
    id_ = 0;
    parentid_ = 0;
  }
  properties_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AECamera::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_transform;
        break;
      }
      
      // required .aefilter.AETransform transform = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transform:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transform()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_FOV;
        break;
      }
      
      // required float FOV = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_FOV:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fov_)));
          set_has_fov();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_id;
        break;
      }
      
      // required int32 id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_properties;
        break;
      }
      
      // repeated .aefilter.AEKeyPair properties = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_properties:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_properties()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_properties;
        if (input->ExpectTag(88)) goto parse_parentid;
        break;
      }
      
      // optional int32 parentid = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_parentid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &parentid_)));
          set_has_parentid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AECamera::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required .aefilter.AETransform transform = 2;
  if (has_transform()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->transform(), output);
  }
  
  // required float FOV = 3;
  if (has_fov()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->fov(), output);
  }
  
  // required int32 id = 4;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->id(), output);
  }
  
  // repeated .aefilter.AEKeyPair properties = 5;
  for (int i = 0; i < this->properties_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->properties(i), output);
  }
  
  // optional int32 parentid = 11;
  if (has_parentid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->parentid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AECamera::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required .aefilter.AETransform transform = 2;
  if (has_transform()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->transform(), target);
  }
  
  // required float FOV = 3;
  if (has_fov()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->fov(), target);
  }
  
  // required int32 id = 4;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->id(), target);
  }
  
  // repeated .aefilter.AEKeyPair properties = 5;
  for (int i = 0; i < this->properties_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->properties(i), target);
  }
  
  // optional int32 parentid = 11;
  if (has_parentid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->parentid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AECamera::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required .aefilter.AETransform transform = 2;
    if (has_transform()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transform());
    }
    
    // required float FOV = 3;
    if (has_fov()) {
      total_size += 1 + 4;
    }
    
    // required int32 id = 4;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // optional int32 parentid = 11;
    if (has_parentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->parentid());
    }
    
  }
  // repeated .aefilter.AEKeyPair properties = 5;
  total_size += 1 * this->properties_size();
  for (int i = 0; i < this->properties_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->properties(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AECamera::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AECamera* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AECamera*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AECamera::MergeFrom(const AECamera& from) {
  GOOGLE_CHECK_NE(&from, this);
  properties_.MergeFrom(from.properties_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_transform()) {
      mutable_transform()->::aefilter::AETransform::MergeFrom(from.transform());
    }
    if (from.has_fov()) {
      set_fov(from.fov());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_parentid()) {
      set_parentid(from.parentid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AECamera::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AECamera::CopyFrom(const AECamera& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AECamera::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  if (has_transform()) {
    if (!this->transform().IsInitialized()) return false;
  }
  for (int i = 0; i < properties_size(); i++) {
    if (!this->properties(i).IsInitialized()) return false;
  }
  return true;
}

void AECamera::Swap(AECamera* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(transform_, other->transform_);
    std::swap(fov_, other->fov_);
    std::swap(id_, other->id_);
    properties_.Swap(&other->properties_);
    std::swap(parentid_, other->parentid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AECamera::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AECamera_descriptor_;
  metadata.reflection = AECamera_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AELight::kNameFieldNumber;
const int AELight::kTransformFieldNumber;
const int AELight::kTypeFieldNumber;
const int AELight::kColorFieldNumber;
const int AELight::kCastsshadowsFieldNumber;
const int AELight::kParentnameFieldNumber;
const int AELight::kRadiusFieldNumber;
const int AELight::kFalloffFieldNumber;
const int AELight::kSpotexponentFieldNumber;
const int AELight::kSpotcosineFieldNumber;
const int AELight::kIdFieldNumber;
#endif  // !_MSC_VER

AELight::AELight()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AELight::InitAsDefaultInstance() {
  transform_ = const_cast< ::aefilter::AETransform*>(&::aefilter::AETransform::default_instance());
  color_ = const_cast< ::aefilter::AEVector*>(&::aefilter::AEVector::default_instance());
}

AELight::AELight(const AELight& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AELight::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  transform_ = NULL;
  type_ = 0;
  color_ = NULL;
  castsshadows_ = false;
  parentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  radius_ = 0;
  falloff_ = 0;
  spotexponent_ = 0;
  spotcosine_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AELight::~AELight() {
  SharedDtor();
}

void AELight::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (parentname_ != &::google::protobuf::internal::kEmptyString) {
    delete parentname_;
  }
  if (this != default_instance_) {
    delete transform_;
    delete color_;
  }
}

void AELight::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AELight::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AELight_descriptor_;
}

const AELight& AELight::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AELight* AELight::default_instance_ = NULL;

AELight* AELight::New() const {
  return new AELight;
}

void AELight::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_transform()) {
      if (transform_ != NULL) transform_->::aefilter::AETransform::Clear();
    }
    type_ = 0;
    if (has_color()) {
      if (color_ != NULL) color_->::aefilter::AEVector::Clear();
    }
    castsshadows_ = false;
    if (has_parentname()) {
      if (parentname_ != &::google::protobuf::internal::kEmptyString) {
        parentname_->clear();
      }
    }
    radius_ = 0;
    falloff_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    spotexponent_ = 0;
    spotcosine_ = 0;
    id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AELight::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_transform;
        break;
      }
      
      // required .aefilter.AETransform transform = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transform:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transform()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }
      
      // required .aefilter.AELightType type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (aefilter::AELightType_IsValid(value)) {
            set_type(static_cast< aefilter::AELightType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_color;
        break;
      }
      
      // required .aefilter.AEVector color = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_castsshadows;
        break;
      }
      
      // required bool castsshadows = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_castsshadows:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &castsshadows_)));
          set_has_castsshadows();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_parentname;
        break;
      }
      
      // required string parentname = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_parentname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_parentname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->parentname().data(), this->parentname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_radius;
        break;
      }
      
      // optional float radius = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_falloff;
        break;
      }
      
      // optional float falloff = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_falloff:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &falloff_)));
          set_has_falloff();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_spotexponent;
        break;
      }
      
      // optional float spotexponent = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_spotexponent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &spotexponent_)));
          set_has_spotexponent();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_spotcosine;
        break;
      }
      
      // optional float spotcosine = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_spotcosine:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &spotcosine_)));
          set_has_spotcosine();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_id;
        break;
      }
      
      // required int32 id = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AELight::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required .aefilter.AETransform transform = 2;
  if (has_transform()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->transform(), output);
  }
  
  // required .aefilter.AELightType type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }
  
  // required .aefilter.AEVector color = 4;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->color(), output);
  }
  
  // required bool castsshadows = 5;
  if (has_castsshadows()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->castsshadows(), output);
  }
  
  // required string parentname = 6;
  if (has_parentname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->parentname().data(), this->parentname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->parentname(), output);
  }
  
  // optional float radius = 7;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->radius(), output);
  }
  
  // optional float falloff = 8;
  if (has_falloff()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->falloff(), output);
  }
  
  // optional float spotexponent = 9;
  if (has_spotexponent()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->spotexponent(), output);
  }
  
  // optional float spotcosine = 10;
  if (has_spotcosine()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->spotcosine(), output);
  }
  
  // required int32 id = 11;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AELight::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required .aefilter.AETransform transform = 2;
  if (has_transform()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->transform(), target);
  }
  
  // required .aefilter.AELightType type = 3;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }
  
  // required .aefilter.AEVector color = 4;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->color(), target);
  }
  
  // required bool castsshadows = 5;
  if (has_castsshadows()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->castsshadows(), target);
  }
  
  // required string parentname = 6;
  if (has_parentname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->parentname().data(), this->parentname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->parentname(), target);
  }
  
  // optional float radius = 7;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->radius(), target);
  }
  
  // optional float falloff = 8;
  if (has_falloff()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->falloff(), target);
  }
  
  // optional float spotexponent = 9;
  if (has_spotexponent()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->spotexponent(), target);
  }
  
  // optional float spotcosine = 10;
  if (has_spotcosine()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->spotcosine(), target);
  }
  
  // required int32 id = 11;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AELight::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required .aefilter.AETransform transform = 2;
    if (has_transform()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transform());
    }
    
    // required .aefilter.AELightType type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // required .aefilter.AEVector color = 4;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->color());
    }
    
    // required bool castsshadows = 5;
    if (has_castsshadows()) {
      total_size += 1 + 1;
    }
    
    // required string parentname = 6;
    if (has_parentname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->parentname());
    }
    
    // optional float radius = 7;
    if (has_radius()) {
      total_size += 1 + 4;
    }
    
    // optional float falloff = 8;
    if (has_falloff()) {
      total_size += 1 + 4;
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float spotexponent = 9;
    if (has_spotexponent()) {
      total_size += 1 + 4;
    }
    
    // optional float spotcosine = 10;
    if (has_spotcosine()) {
      total_size += 1 + 4;
    }
    
    // required int32 id = 11;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AELight::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AELight* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AELight*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AELight::MergeFrom(const AELight& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_transform()) {
      mutable_transform()->::aefilter::AETransform::MergeFrom(from.transform());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_color()) {
      mutable_color()->::aefilter::AEVector::MergeFrom(from.color());
    }
    if (from.has_castsshadows()) {
      set_castsshadows(from.castsshadows());
    }
    if (from.has_parentname()) {
      set_parentname(from.parentname());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
    if (from.has_falloff()) {
      set_falloff(from.falloff());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_spotexponent()) {
      set_spotexponent(from.spotexponent());
    }
    if (from.has_spotcosine()) {
      set_spotcosine(from.spotcosine());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AELight::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AELight::CopyFrom(const AELight& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AELight::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000043f) != 0x0000043f) return false;
  
  if (has_transform()) {
    if (!this->transform().IsInitialized()) return false;
  }
  if (has_color()) {
    if (!this->color().IsInitialized()) return false;
  }
  return true;
}

void AELight::Swap(AELight* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(transform_, other->transform_);
    std::swap(type_, other->type_);
    std::swap(color_, other->color_);
    std::swap(castsshadows_, other->castsshadows_);
    std::swap(parentname_, other->parentname_);
    std::swap(radius_, other->radius_);
    std::swap(falloff_, other->falloff_);
    std::swap(spotexponent_, other->spotexponent_);
    std::swap(spotcosine_, other->spotcosine_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AELight::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AELight_descriptor_;
  metadata.reflection = AELight_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AETrackIdentifier::kTargetidFieldNumber;
const int AETrackIdentifier::kBindingFieldNumber;
#endif  // !_MSC_VER

AETrackIdentifier::AETrackIdentifier()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AETrackIdentifier::InitAsDefaultInstance() {
}

AETrackIdentifier::AETrackIdentifier(const AETrackIdentifier& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AETrackIdentifier::SharedCtor() {
  _cached_size_ = 0;
  targetid_ = 0;
  binding_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AETrackIdentifier::~AETrackIdentifier() {
  SharedDtor();
}

void AETrackIdentifier::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AETrackIdentifier::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AETrackIdentifier::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AETrackIdentifier_descriptor_;
}

const AETrackIdentifier& AETrackIdentifier::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AETrackIdentifier* AETrackIdentifier::default_instance_ = NULL;

AETrackIdentifier* AETrackIdentifier::New() const {
  return new AETrackIdentifier;
}

void AETrackIdentifier::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    targetid_ = 0;
    binding_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AETrackIdentifier::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 targetid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &targetid_)));
          set_has_targetid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_binding;
        break;
      }
      
      // required .aefilter.AEBinding binding = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_binding:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (aefilter::AEBinding_IsValid(value)) {
            set_binding(static_cast< aefilter::AEBinding >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AETrackIdentifier::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 targetid = 1;
  if (has_targetid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->targetid(), output);
  }
  
  // required .aefilter.AEBinding binding = 2;
  if (has_binding()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->binding(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AETrackIdentifier::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 targetid = 1;
  if (has_targetid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->targetid(), target);
  }
  
  // required .aefilter.AEBinding binding = 2;
  if (has_binding()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->binding(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AETrackIdentifier::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 targetid = 1;
    if (has_targetid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->targetid());
    }
    
    // required .aefilter.AEBinding binding = 2;
    if (has_binding()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->binding());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AETrackIdentifier::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AETrackIdentifier* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AETrackIdentifier*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AETrackIdentifier::MergeFrom(const AETrackIdentifier& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_targetid()) {
      set_targetid(from.targetid());
    }
    if (from.has_binding()) {
      set_binding(from.binding());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AETrackIdentifier::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AETrackIdentifier::CopyFrom(const AETrackIdentifier& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AETrackIdentifier::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void AETrackIdentifier::Swap(AETrackIdentifier* other) {
  if (other != this) {
    std::swap(targetid_, other->targetid_);
    std::swap(binding_, other->binding_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AETrackIdentifier::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AETrackIdentifier_descriptor_;
  metadata.reflection = AETrackIdentifier_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AEComposition::kNameFieldNumber;
const int AEComposition::kWidthFieldNumber;
const int AEComposition::kHeightFieldNumber;
const int AEComposition::kDefaultcameradistanceFieldNumber;
const int AEComposition::kCameraFieldNumber;
const int AEComposition::kLayerFieldNumber;
const int AEComposition::kLightsFieldNumber;
const int AEComposition::kClassnameFieldNumber;
const int AEComposition::kBgcolorFieldNumber;
const int AEComposition::kDEPRECATEDStylenameFieldNumber;
const int AEComposition::kPackagenameFieldNumber;
const int AEComposition::kPropertiesFieldNumber;
const int AEComposition::kChildtemplatesFieldNumber;
#endif  // !_MSC_VER

AEComposition::AEComposition()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AEComposition::InitAsDefaultInstance() {
  bgcolor_ = const_cast< ::aefilter::AEColor*>(&::aefilter::AEColor::default_instance());
}

AEComposition::AEComposition(const AEComposition& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AEComposition::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  width_ = 0;
  height_ = 0;
  defaultcameradistance_ = 0;
  classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  bgcolor_ = NULL;
  deprecated_stylename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  packagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AEComposition::~AEComposition() {
  SharedDtor();
}

void AEComposition::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (deprecated_stylename_ != &::google::protobuf::internal::kEmptyString) {
    delete deprecated_stylename_;
  }
  if (packagename_ != &::google::protobuf::internal::kEmptyString) {
    delete packagename_;
  }
  if (this != default_instance_) {
    delete bgcolor_;
  }
}

void AEComposition::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AEComposition::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEComposition_descriptor_;
}

const AEComposition& AEComposition::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AEComposition* AEComposition::default_instance_ = NULL;

AEComposition* AEComposition::New() const {
  return new AEComposition;
}

void AEComposition::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    width_ = 0;
    height_ = 0;
    defaultcameradistance_ = 0;
    if (has_classname()) {
      if (classname_ != &::google::protobuf::internal::kEmptyString) {
        classname_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_bgcolor()) {
      if (bgcolor_ != NULL) bgcolor_->::aefilter::AEColor::Clear();
    }
    if (has_deprecated_stylename()) {
      if (deprecated_stylename_ != &::google::protobuf::internal::kEmptyString) {
        deprecated_stylename_->clear();
      }
    }
    if (has_packagename()) {
      if (packagename_ != &::google::protobuf::internal::kEmptyString) {
        packagename_->clear();
      }
    }
  }
  camera_.Clear();
  layer_.Clear();
  lights_.Clear();
  properties_.Clear();
  childtemplates_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AEComposition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_width;
        break;
      }
      
      // required float width = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_height;
        break;
      }
      
      // required float height = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_defaultcameradistance;
        break;
      }
      
      // required float defaultcameradistance = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_defaultcameradistance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &defaultcameradistance_)));
          set_has_defaultcameradistance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_camera;
        break;
      }
      
      // repeated .aefilter.AECamera camera = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_camera:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_camera()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_camera;
        if (input->ExpectTag(50)) goto parse_layer;
        break;
      }
      
      // repeated .aefilter.AELayer layer = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_layer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_layer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_layer;
        if (input->ExpectTag(58)) goto parse_lights;
        break;
      }
      
      // repeated .aefilter.AELight lights = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lights:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lights()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_lights;
        if (input->ExpectTag(66)) goto parse_classname;
        break;
      }
      
      // optional string classname = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_classname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_classname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->classname().data(), this->classname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_bgcolor;
        break;
      }
      
      // optional .aefilter.AEColor bgcolor = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bgcolor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bgcolor()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_DEPRECATED_stylename;
        break;
      }
      
      // optional string DEPRECATED_stylename = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DEPRECATED_stylename:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_deprecated_stylename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->deprecated_stylename().data(), this->deprecated_stylename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_packagename;
        break;
      }
      
      // optional string packagename = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_packagename:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_packagename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->packagename().data(), this->packagename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_properties;
        break;
      }
      
      // repeated .aefilter.AEKeyPair properties = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_properties:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_properties()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_properties;
        if (input->ExpectTag(106)) goto parse_childtemplates;
        break;
      }
      
      // repeated string childtemplates = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_childtemplates:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_childtemplates()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->childtemplates(0).data(), this->childtemplates(0).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_childtemplates;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AEComposition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required float width = 2;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->width(), output);
  }
  
  // required float height = 3;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->height(), output);
  }
  
  // required float defaultcameradistance = 4;
  if (has_defaultcameradistance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->defaultcameradistance(), output);
  }
  
  // repeated .aefilter.AECamera camera = 5;
  for (int i = 0; i < this->camera_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->camera(i), output);
  }
  
  // repeated .aefilter.AELayer layer = 6;
  for (int i = 0; i < this->layer_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->layer(i), output);
  }
  
  // repeated .aefilter.AELight lights = 7;
  for (int i = 0; i < this->lights_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->lights(i), output);
  }
  
  // optional string classname = 8;
  if (has_classname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->classname().data(), this->classname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->classname(), output);
  }
  
  // optional .aefilter.AEColor bgcolor = 9;
  if (has_bgcolor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->bgcolor(), output);
  }
  
  // optional string DEPRECATED_stylename = 10;
  if (has_deprecated_stylename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->deprecated_stylename().data(), this->deprecated_stylename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->deprecated_stylename(), output);
  }
  
  // optional string packagename = 11;
  if (has_packagename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->packagename().data(), this->packagename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->packagename(), output);
  }
  
  // repeated .aefilter.AEKeyPair properties = 12;
  for (int i = 0; i < this->properties_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->properties(i), output);
  }
  
  // repeated string childtemplates = 13;
  for (int i = 0; i < this->childtemplates_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->childtemplates(i).data(), this->childtemplates(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->childtemplates(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AEComposition::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required float width = 2;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->width(), target);
  }
  
  // required float height = 3;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->height(), target);
  }
  
  // required float defaultcameradistance = 4;
  if (has_defaultcameradistance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->defaultcameradistance(), target);
  }
  
  // repeated .aefilter.AECamera camera = 5;
  for (int i = 0; i < this->camera_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->camera(i), target);
  }
  
  // repeated .aefilter.AELayer layer = 6;
  for (int i = 0; i < this->layer_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->layer(i), target);
  }
  
  // repeated .aefilter.AELight lights = 7;
  for (int i = 0; i < this->lights_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->lights(i), target);
  }
  
  // optional string classname = 8;
  if (has_classname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->classname().data(), this->classname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->classname(), target);
  }
  
  // optional .aefilter.AEColor bgcolor = 9;
  if (has_bgcolor()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->bgcolor(), target);
  }
  
  // optional string DEPRECATED_stylename = 10;
  if (has_deprecated_stylename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->deprecated_stylename().data(), this->deprecated_stylename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->deprecated_stylename(), target);
  }
  
  // optional string packagename = 11;
  if (has_packagename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->packagename().data(), this->packagename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->packagename(), target);
  }
  
  // repeated .aefilter.AEKeyPair properties = 12;
  for (int i = 0; i < this->properties_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->properties(i), target);
  }
  
  // repeated string childtemplates = 13;
  for (int i = 0; i < this->childtemplates_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->childtemplates(i).data(), this->childtemplates(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(13, this->childtemplates(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AEComposition::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required float width = 2;
    if (has_width()) {
      total_size += 1 + 4;
    }
    
    // required float height = 3;
    if (has_height()) {
      total_size += 1 + 4;
    }
    
    // required float defaultcameradistance = 4;
    if (has_defaultcameradistance()) {
      total_size += 1 + 4;
    }
    
    // optional string classname = 8;
    if (has_classname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->classname());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .aefilter.AEColor bgcolor = 9;
    if (has_bgcolor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bgcolor());
    }
    
    // optional string DEPRECATED_stylename = 10;
    if (has_deprecated_stylename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->deprecated_stylename());
    }
    
    // optional string packagename = 11;
    if (has_packagename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->packagename());
    }
    
  }
  // repeated .aefilter.AECamera camera = 5;
  total_size += 1 * this->camera_size();
  for (int i = 0; i < this->camera_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->camera(i));
  }
  
  // repeated .aefilter.AELayer layer = 6;
  total_size += 1 * this->layer_size();
  for (int i = 0; i < this->layer_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->layer(i));
  }
  
  // repeated .aefilter.AELight lights = 7;
  total_size += 1 * this->lights_size();
  for (int i = 0; i < this->lights_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lights(i));
  }
  
  // repeated .aefilter.AEKeyPair properties = 12;
  total_size += 1 * this->properties_size();
  for (int i = 0; i < this->properties_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->properties(i));
  }
  
  // repeated string childtemplates = 13;
  total_size += 1 * this->childtemplates_size();
  for (int i = 0; i < this->childtemplates_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->childtemplates(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AEComposition::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AEComposition* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AEComposition*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AEComposition::MergeFrom(const AEComposition& from) {
  GOOGLE_CHECK_NE(&from, this);
  camera_.MergeFrom(from.camera_);
  layer_.MergeFrom(from.layer_);
  lights_.MergeFrom(from.lights_);
  properties_.MergeFrom(from.properties_);
  childtemplates_.MergeFrom(from.childtemplates_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_defaultcameradistance()) {
      set_defaultcameradistance(from.defaultcameradistance());
    }
    if (from.has_classname()) {
      set_classname(from.classname());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_bgcolor()) {
      mutable_bgcolor()->::aefilter::AEColor::MergeFrom(from.bgcolor());
    }
    if (from.has_deprecated_stylename()) {
      set_deprecated_stylename(from.deprecated_stylename());
    }
    if (from.has_packagename()) {
      set_packagename(from.packagename());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AEComposition::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AEComposition::CopyFrom(const AEComposition& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AEComposition::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  for (int i = 0; i < camera_size(); i++) {
    if (!this->camera(i).IsInitialized()) return false;
  }
  for (int i = 0; i < layer_size(); i++) {
    if (!this->layer(i).IsInitialized()) return false;
  }
  for (int i = 0; i < lights_size(); i++) {
    if (!this->lights(i).IsInitialized()) return false;
  }
  if (has_bgcolor()) {
    if (!this->bgcolor().IsInitialized()) return false;
  }
  for (int i = 0; i < properties_size(); i++) {
    if (!this->properties(i).IsInitialized()) return false;
  }
  return true;
}

void AEComposition::Swap(AEComposition* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(defaultcameradistance_, other->defaultcameradistance_);
    camera_.Swap(&other->camera_);
    layer_.Swap(&other->layer_);
    lights_.Swap(&other->lights_);
    std::swap(classname_, other->classname_);
    std::swap(bgcolor_, other->bgcolor_);
    std::swap(deprecated_stylename_, other->deprecated_stylename_);
    std::swap(packagename_, other->packagename_);
    properties_.Swap(&other->properties_);
    childtemplates_.Swap(&other->childtemplates_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AEComposition::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AEComposition_descriptor_;
  metadata.reflection = AEComposition_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AESource::kUidFieldNumber;
const int AESource::kSrctypeFieldNumber;
const int AESource::kNameFieldNumber;
const int AESource::kCompFieldNumber;
const int AESource::kColorFieldNumber;
const int AESource::kWidthFieldNumber;
const int AESource::kHeightFieldNumber;
const int AESource::kNumberOfFramesFieldNumber;
const int AESource::kFpsFieldNumber;
const int AESource::kLoopsFieldNumber;
const int AESource::kCopySourceFieldNumber;
const int AESource::kFileNameFieldNumber;
#endif  // !_MSC_VER

AESource::AESource()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AESource::InitAsDefaultInstance() {
  comp_ = const_cast< ::aefilter::AEComposition*>(&::aefilter::AEComposition::default_instance());
  color_ = const_cast< ::aefilter::AEColor*>(&::aefilter::AEColor::default_instance());
}

AESource::AESource(const AESource& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AESource::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0;
  srctype_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  comp_ = NULL;
  color_ = NULL;
  width_ = 0;
  height_ = 0;
  numberofframes_ = 0;
  fps_ = 0;
  loops_ = 0;
  copy_source_ = false;
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AESource::~AESource() {
  SharedDtor();
}

void AESource::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (this != default_instance_) {
    delete comp_;
    delete color_;
  }
}

void AESource::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AESource::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AESource_descriptor_;
}

const AESource& AESource::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AESource* AESource::default_instance_ = NULL;

AESource* AESource::New() const {
  return new AESource;
}

void AESource::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0;
    srctype_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_comp()) {
      if (comp_ != NULL) comp_->::aefilter::AEComposition::Clear();
    }
    if (has_color()) {
      if (color_ != NULL) color_->::aefilter::AEColor::Clear();
    }
    width_ = 0;
    height_ = 0;
    numberofframes_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    fps_ = 0;
    loops_ = 0;
    copy_source_ = false;
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::kEmptyString) {
        file_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AESource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_srctype;
        break;
      }
      
      // required .aefilter.AESourceType srctype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_srctype:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (aefilter::AESourceType_IsValid(value)) {
            set_srctype(static_cast< aefilter::AESourceType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }
      
      // optional string name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_comp;
        break;
      }
      
      // optional .aefilter.AEComposition comp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_comp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_comp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_color;
        break;
      }
      
      // optional .aefilter.AEColor color = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_width;
        break;
      }
      
      // optional int32 width = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_height;
        break;
      }
      
      // optional int32 height = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_numberOfFrames;
        break;
      }
      
      // optional int32 numberOfFrames = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_numberOfFrames:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &numberofframes_)));
          set_has_numberofframes();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_fps;
        break;
      }
      
      // optional int32 fps = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fps_)));
          set_has_fps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_loops;
        break;
      }
      
      // optional int32 loops = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_loops:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &loops_)));
          set_has_loops();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_copy_source;
        break;
      }
      
      // optional bool copy_source = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_copy_source:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &copy_source_)));
          set_has_copy_source();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_file_name;
        break;
      }
      
      // optional string file_name = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->file_name().data(), this->file_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AESource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->uid(), output);
  }
  
  // required .aefilter.AESourceType srctype = 2;
  if (has_srctype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->srctype(), output);
  }
  
  // optional string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->name(), output);
  }
  
  // optional .aefilter.AEComposition comp = 4;
  if (has_comp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->comp(), output);
  }
  
  // optional .aefilter.AEColor color = 5;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->color(), output);
  }
  
  // optional int32 width = 6;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->width(), output);
  }
  
  // optional int32 height = 7;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->height(), output);
  }
  
  // optional int32 numberOfFrames = 9;
  if (has_numberofframes()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->numberofframes(), output);
  }
  
  // optional int32 fps = 10;
  if (has_fps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->fps(), output);
  }
  
  // optional int32 loops = 11;
  if (has_loops()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->loops(), output);
  }
  
  // optional bool copy_source = 12;
  if (has_copy_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->copy_source(), output);
  }
  
  // optional string file_name = 13;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->file_name().data(), this->file_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->file_name(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AESource::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->uid(), target);
  }
  
  // required .aefilter.AESourceType srctype = 2;
  if (has_srctype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->srctype(), target);
  }
  
  // optional string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->name(), target);
  }
  
  // optional .aefilter.AEComposition comp = 4;
  if (has_comp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->comp(), target);
  }
  
  // optional .aefilter.AEColor color = 5;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->color(), target);
  }
  
  // optional int32 width = 6;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->width(), target);
  }
  
  // optional int32 height = 7;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->height(), target);
  }
  
  // optional int32 numberOfFrames = 9;
  if (has_numberofframes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->numberofframes(), target);
  }
  
  // optional int32 fps = 10;
  if (has_fps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->fps(), target);
  }
  
  // optional int32 loops = 11;
  if (has_loops()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->loops(), target);
  }
  
  // optional bool copy_source = 12;
  if (has_copy_source()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->copy_source(), target);
  }
  
  // optional string file_name = 13;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->file_name().data(), this->file_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->file_name(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AESource::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }
    
    // required .aefilter.AESourceType srctype = 2;
    if (has_srctype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->srctype());
    }
    
    // optional string name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional .aefilter.AEComposition comp = 4;
    if (has_comp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->comp());
    }
    
    // optional .aefilter.AEColor color = 5;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->color());
    }
    
    // optional int32 width = 6;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }
    
    // optional int32 height = 7;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }
    
    // optional int32 numberOfFrames = 9;
    if (has_numberofframes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->numberofframes());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 fps = 10;
    if (has_fps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fps());
    }
    
    // optional int32 loops = 11;
    if (has_loops()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->loops());
    }
    
    // optional bool copy_source = 12;
    if (has_copy_source()) {
      total_size += 1 + 1;
    }
    
    // optional string file_name = 13;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AESource::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AESource* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AESource*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AESource::MergeFrom(const AESource& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_srctype()) {
      set_srctype(from.srctype());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_comp()) {
      mutable_comp()->::aefilter::AEComposition::MergeFrom(from.comp());
    }
    if (from.has_color()) {
      mutable_color()->::aefilter::AEColor::MergeFrom(from.color());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_numberofframes()) {
      set_numberofframes(from.numberofframes());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_fps()) {
      set_fps(from.fps());
    }
    if (from.has_loops()) {
      set_loops(from.loops());
    }
    if (from.has_copy_source()) {
      set_copy_source(from.copy_source());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AESource::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AESource::CopyFrom(const AESource& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AESource::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_comp()) {
    if (!this->comp().IsInitialized()) return false;
  }
  if (has_color()) {
    if (!this->color().IsInitialized()) return false;
  }
  return true;
}

void AESource::Swap(AESource* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(srctype_, other->srctype_);
    std::swap(name_, other->name_);
    std::swap(comp_, other->comp_);
    std::swap(color_, other->color_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(numberofframes_, other->numberofframes_);
    std::swap(fps_, other->fps_);
    std::swap(loops_, other->loops_);
    std::swap(copy_source_, other->copy_source_);
    std::swap(file_name_, other->file_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AESource::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AESource_descriptor_;
  metadata.reflection = AESource_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AELayout::kActivecompFieldNumber;
const int AELayout::kSourcesFieldNumber;
#endif  // !_MSC_VER

AELayout::AELayout()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AELayout::InitAsDefaultInstance() {
  activecomp_ = const_cast< ::aefilter::AEComposition*>(&::aefilter::AEComposition::default_instance());
}

AELayout::AELayout(const AELayout& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AELayout::SharedCtor() {
  _cached_size_ = 0;
  activecomp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AELayout::~AELayout() {
  SharedDtor();
}

void AELayout::SharedDtor() {
  if (this != default_instance_) {
    delete activecomp_;
  }
}

void AELayout::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AELayout::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AELayout_descriptor_;
}

const AELayout& AELayout::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AELayout* AELayout::default_instance_ = NULL;

AELayout* AELayout::New() const {
  return new AELayout;
}

void AELayout::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_activecomp()) {
      if (activecomp_ != NULL) activecomp_->::aefilter::AEComposition::Clear();
    }
  }
  sources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AELayout::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .aefilter.AEComposition activecomp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_activecomp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_sources;
        break;
      }
      
      // repeated .aefilter.AESource sources = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_sources;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AELayout::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .aefilter.AEComposition activecomp = 1;
  if (has_activecomp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->activecomp(), output);
  }
  
  // repeated .aefilter.AESource sources = 2;
  for (int i = 0; i < this->sources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->sources(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AELayout::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .aefilter.AEComposition activecomp = 1;
  if (has_activecomp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->activecomp(), target);
  }
  
  // repeated .aefilter.AESource sources = 2;
  for (int i = 0; i < this->sources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->sources(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AELayout::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .aefilter.AEComposition activecomp = 1;
    if (has_activecomp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->activecomp());
    }
    
  }
  // repeated .aefilter.AESource sources = 2;
  total_size += 1 * this->sources_size();
  for (int i = 0; i < this->sources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sources(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AELayout::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AELayout* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AELayout*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AELayout::MergeFrom(const AELayout& from) {
  GOOGLE_CHECK_NE(&from, this);
  sources_.MergeFrom(from.sources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_activecomp()) {
      mutable_activecomp()->::aefilter::AEComposition::MergeFrom(from.activecomp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AELayout::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AELayout::CopyFrom(const AELayout& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AELayout::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_activecomp()) {
    if (!this->activecomp().IsInitialized()) return false;
  }
  for (int i = 0; i < sources_size(); i++) {
    if (!this->sources(i).IsInitialized()) return false;
  }
  return true;
}

void AELayout::Swap(AELayout* other) {
  if (other != this) {
    std::swap(activecomp_, other->activecomp_);
    sources_.Swap(&other->sources_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AELayout::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AELayout_descriptor_;
  metadata.reflection = AELayout_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AEKeytimeEase::kSpeedInFieldNumber;
const int AEKeytimeEase::kInfluenceInFieldNumber;
const int AEKeytimeEase::kSpeedOutFieldNumber;
const int AEKeytimeEase::kInfluenceOutFieldNumber;
#endif  // !_MSC_VER

AEKeytimeEase::AEKeytimeEase()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AEKeytimeEase::InitAsDefaultInstance() {
}

AEKeytimeEase::AEKeytimeEase(const AEKeytimeEase& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AEKeytimeEase::SharedCtor() {
  _cached_size_ = 0;
  speedin_ = 0;
  influencein_ = 0;
  speedout_ = 0;
  influenceout_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AEKeytimeEase::~AEKeytimeEase() {
  SharedDtor();
}

void AEKeytimeEase::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AEKeytimeEase::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AEKeytimeEase::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEKeytimeEase_descriptor_;
}

const AEKeytimeEase& AEKeytimeEase::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AEKeytimeEase* AEKeytimeEase::default_instance_ = NULL;

AEKeytimeEase* AEKeytimeEase::New() const {
  return new AEKeytimeEase;
}

void AEKeytimeEase::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    speedin_ = 0;
    influencein_ = 0;
    speedout_ = 0;
    influenceout_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AEKeytimeEase::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float speedIn = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speedin_)));
          set_has_speedin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_influenceIn;
        break;
      }
      
      // required float influenceIn = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_influenceIn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &influencein_)));
          set_has_influencein();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_speedOut;
        break;
      }
      
      // required float speedOut = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_speedOut:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speedout_)));
          set_has_speedout();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_influenceOut;
        break;
      }
      
      // required float influenceOut = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_influenceOut:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &influenceout_)));
          set_has_influenceout();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AEKeytimeEase::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float speedIn = 1;
  if (has_speedin()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->speedin(), output);
  }
  
  // required float influenceIn = 2;
  if (has_influencein()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->influencein(), output);
  }
  
  // required float speedOut = 3;
  if (has_speedout()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->speedout(), output);
  }
  
  // required float influenceOut = 4;
  if (has_influenceout()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->influenceout(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AEKeytimeEase::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float speedIn = 1;
  if (has_speedin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->speedin(), target);
  }
  
  // required float influenceIn = 2;
  if (has_influencein()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->influencein(), target);
  }
  
  // required float speedOut = 3;
  if (has_speedout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->speedout(), target);
  }
  
  // required float influenceOut = 4;
  if (has_influenceout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->influenceout(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AEKeytimeEase::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float speedIn = 1;
    if (has_speedin()) {
      total_size += 1 + 4;
    }
    
    // required float influenceIn = 2;
    if (has_influencein()) {
      total_size += 1 + 4;
    }
    
    // required float speedOut = 3;
    if (has_speedout()) {
      total_size += 1 + 4;
    }
    
    // required float influenceOut = 4;
    if (has_influenceout()) {
      total_size += 1 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AEKeytimeEase::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AEKeytimeEase* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AEKeytimeEase*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AEKeytimeEase::MergeFrom(const AEKeytimeEase& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_speedin()) {
      set_speedin(from.speedin());
    }
    if (from.has_influencein()) {
      set_influencein(from.influencein());
    }
    if (from.has_speedout()) {
      set_speedout(from.speedout());
    }
    if (from.has_influenceout()) {
      set_influenceout(from.influenceout());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AEKeytimeEase::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AEKeytimeEase::CopyFrom(const AEKeytimeEase& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AEKeytimeEase::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

void AEKeytimeEase::Swap(AEKeytimeEase* other) {
  if (other != this) {
    std::swap(speedin_, other->speedin_);
    std::swap(influencein_, other->influencein_);
    std::swap(speedout_, other->speedout_);
    std::swap(influenceout_, other->influenceout_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AEKeytimeEase::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AEKeytimeEase_descriptor_;
  metadata.reflection = AEKeytimeEase_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AEKeytime::kDatatypeFieldNumber;
const int AEKeytime::kTimeOffsetFieldNumber;
const int AEKeytime::kInttypeFieldNumber;
const int AEKeytime::kObsoleteSpeedInFieldNumber;
const int AEKeytime::kObsoleteInfluenceInFieldNumber;
const int AEKeytime::kObsoleteSpeedOutFieldNumber;
const int AEKeytime::kObsoleteInfluenceOutFieldNumber;
const int AEKeytime::kSInTangentXFieldNumber;
const int AEKeytime::kSInTangentYFieldNumber;
const int AEKeytime::kSInTangentZFieldNumber;
const int AEKeytime::kSOutTangentXFieldNumber;
const int AEKeytime::kSOutTangentYFieldNumber;
const int AEKeytime::kSOutTangentZFieldNumber;
const int AEKeytime::kFvalue1FieldNumber;
const int AEKeytime::kFvalue2FieldNumber;
const int AEKeytime::kFvalue3FieldNumber;
const int AEKeytime::kIvalue1FieldNumber;
const int AEKeytime::kEaseValuesFieldNumber;
const int AEKeytime::kIsCookedKeytimeFieldNumber;
#endif  // !_MSC_VER

AEKeytime::AEKeytime()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AEKeytime::InitAsDefaultInstance() {
}

AEKeytime::AEKeytime(const AEKeytime& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AEKeytime::SharedCtor() {
  _cached_size_ = 0;
  datatype_ = 0;
  timeoffset_ = 0;
  inttype_ = 0;
  obsoletespeedin_ = 0;
  obsoleteinfluencein_ = 0;
  obsoletespeedout_ = 0;
  obsoleteinfluenceout_ = 0;
  sintangentx_ = 0;
  sintangenty_ = 0;
  sintangentz_ = 0;
  souttangentx_ = 0;
  souttangenty_ = 0;
  souttangentz_ = 0;
  fvalue1_ = 0;
  fvalue2_ = 0;
  fvalue3_ = 0;
  ivalue1_ = 0;
  iscookedkeytime_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AEKeytime::~AEKeytime() {
  SharedDtor();
}

void AEKeytime::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AEKeytime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AEKeytime::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEKeytime_descriptor_;
}

const AEKeytime& AEKeytime::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AEKeytime* AEKeytime::default_instance_ = NULL;

AEKeytime* AEKeytime::New() const {
  return new AEKeytime;
}

void AEKeytime::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    datatype_ = 0;
    timeoffset_ = 0;
    inttype_ = 0;
    obsoletespeedin_ = 0;
    obsoleteinfluencein_ = 0;
    obsoletespeedout_ = 0;
    obsoleteinfluenceout_ = 0;
    sintangentx_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    sintangenty_ = 0;
    sintangentz_ = 0;
    souttangentx_ = 0;
    souttangenty_ = 0;
    souttangentz_ = 0;
    fvalue1_ = 0;
    fvalue2_ = 0;
    fvalue3_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    ivalue1_ = 0;
    iscookedkeytime_ = false;
  }
  easevalues_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AEKeytime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .aefilter.AEDataType datatype = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (aefilter::AEDataType_IsValid(value)) {
            set_datatype(static_cast< aefilter::AEDataType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_timeOffset;
        break;
      }
      
      // required float timeOffset = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_timeOffset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timeoffset_)));
          set_has_timeoffset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_inttype;
        break;
      }
      
      // required .aefilter.AEIType inttype = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_inttype:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (aefilter::AEIType_IsValid(value)) {
            set_inttype(static_cast< aefilter::AEIType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_obsoleteSpeedIn;
        break;
      }
      
      // optional float obsoleteSpeedIn = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_obsoleteSpeedIn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &obsoletespeedin_)));
          set_has_obsoletespeedin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_obsoleteInfluenceIn;
        break;
      }
      
      // optional float obsoleteInfluenceIn = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_obsoleteInfluenceIn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &obsoleteinfluencein_)));
          set_has_obsoleteinfluencein();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_obsoleteSpeedOut;
        break;
      }
      
      // optional float obsoleteSpeedOut = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_obsoleteSpeedOut:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &obsoletespeedout_)));
          set_has_obsoletespeedout();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_obsoleteInfluenceOut;
        break;
      }
      
      // optional float obsoleteInfluenceOut = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_obsoleteInfluenceOut:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &obsoleteinfluenceout_)));
          set_has_obsoleteinfluenceout();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_sInTangentX;
        break;
      }
      
      // optional float sInTangentX = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sInTangentX:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sintangentx_)));
          set_has_sintangentx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_sInTangentY;
        break;
      }
      
      // optional float sInTangentY = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sInTangentY:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sintangenty_)));
          set_has_sintangenty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(93)) goto parse_sInTangentZ;
        break;
      }
      
      // optional float sInTangentZ = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sInTangentZ:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sintangentz_)));
          set_has_sintangentz();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(101)) goto parse_sOutTangentX;
        break;
      }
      
      // optional float sOutTangentX = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sOutTangentX:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &souttangentx_)));
          set_has_souttangentx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(109)) goto parse_sOutTangentY;
        break;
      }
      
      // optional float sOutTangentY = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sOutTangentY:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &souttangenty_)));
          set_has_souttangenty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(117)) goto parse_sOutTangentZ;
        break;
      }
      
      // optional float sOutTangentZ = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sOutTangentZ:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &souttangentz_)));
          set_has_souttangentz();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(125)) goto parse_fvalue1;
        break;
      }
      
      // optional float fvalue1 = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_fvalue1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fvalue1_)));
          set_has_fvalue1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(133)) goto parse_fvalue2;
        break;
      }
      
      // optional float fvalue2 = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_fvalue2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fvalue2_)));
          set_has_fvalue2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(141)) goto parse_fvalue3;
        break;
      }
      
      // optional float fvalue3 = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_fvalue3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fvalue3_)));
          set_has_fvalue3();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(144)) goto parse_ivalue1;
        break;
      }
      
      // optional int32 ivalue1 = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ivalue1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ivalue1_)));
          set_has_ivalue1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_easeValues;
        break;
      }
      
      // repeated .aefilter.AEKeytimeEase easeValues = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_easeValues:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_easevalues()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_easeValues;
        if (input->ExpectTag(160)) goto parse_isCookedKeytime;
        break;
      }
      
      // optional bool isCookedKeytime = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isCookedKeytime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &iscookedkeytime_)));
          set_has_iscookedkeytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AEKeytime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .aefilter.AEDataType datatype = 1;
  if (has_datatype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->datatype(), output);
  }
  
  // required float timeOffset = 2;
  if (has_timeoffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->timeoffset(), output);
  }
  
  // required .aefilter.AEIType inttype = 3;
  if (has_inttype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->inttype(), output);
  }
  
  // optional float obsoleteSpeedIn = 5;
  if (has_obsoletespeedin()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->obsoletespeedin(), output);
  }
  
  // optional float obsoleteInfluenceIn = 6;
  if (has_obsoleteinfluencein()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->obsoleteinfluencein(), output);
  }
  
  // optional float obsoleteSpeedOut = 7;
  if (has_obsoletespeedout()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->obsoletespeedout(), output);
  }
  
  // optional float obsoleteInfluenceOut = 8;
  if (has_obsoleteinfluenceout()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->obsoleteinfluenceout(), output);
  }
  
  // optional float sInTangentX = 9;
  if (has_sintangentx()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->sintangentx(), output);
  }
  
  // optional float sInTangentY = 10;
  if (has_sintangenty()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->sintangenty(), output);
  }
  
  // optional float sInTangentZ = 11;
  if (has_sintangentz()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->sintangentz(), output);
  }
  
  // optional float sOutTangentX = 12;
  if (has_souttangentx()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->souttangentx(), output);
  }
  
  // optional float sOutTangentY = 13;
  if (has_souttangenty()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->souttangenty(), output);
  }
  
  // optional float sOutTangentZ = 14;
  if (has_souttangentz()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->souttangentz(), output);
  }
  
  // optional float fvalue1 = 15;
  if (has_fvalue1()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(15, this->fvalue1(), output);
  }
  
  // optional float fvalue2 = 16;
  if (has_fvalue2()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(16, this->fvalue2(), output);
  }
  
  // optional float fvalue3 = 17;
  if (has_fvalue3()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(17, this->fvalue3(), output);
  }
  
  // optional int32 ivalue1 = 18;
  if (has_ivalue1()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(18, this->ivalue1(), output);
  }
  
  // repeated .aefilter.AEKeytimeEase easeValues = 19;
  for (int i = 0; i < this->easevalues_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      19, this->easevalues(i), output);
  }
  
  // optional bool isCookedKeytime = 20;
  if (has_iscookedkeytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(20, this->iscookedkeytime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AEKeytime::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .aefilter.AEDataType datatype = 1;
  if (has_datatype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->datatype(), target);
  }
  
  // required float timeOffset = 2;
  if (has_timeoffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->timeoffset(), target);
  }
  
  // required .aefilter.AEIType inttype = 3;
  if (has_inttype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->inttype(), target);
  }
  
  // optional float obsoleteSpeedIn = 5;
  if (has_obsoletespeedin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->obsoletespeedin(), target);
  }
  
  // optional float obsoleteInfluenceIn = 6;
  if (has_obsoleteinfluencein()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->obsoleteinfluencein(), target);
  }
  
  // optional float obsoleteSpeedOut = 7;
  if (has_obsoletespeedout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->obsoletespeedout(), target);
  }
  
  // optional float obsoleteInfluenceOut = 8;
  if (has_obsoleteinfluenceout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->obsoleteinfluenceout(), target);
  }
  
  // optional float sInTangentX = 9;
  if (has_sintangentx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->sintangentx(), target);
  }
  
  // optional float sInTangentY = 10;
  if (has_sintangenty()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->sintangenty(), target);
  }
  
  // optional float sInTangentZ = 11;
  if (has_sintangentz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->sintangentz(), target);
  }
  
  // optional float sOutTangentX = 12;
  if (has_souttangentx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->souttangentx(), target);
  }
  
  // optional float sOutTangentY = 13;
  if (has_souttangenty()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->souttangenty(), target);
  }
  
  // optional float sOutTangentZ = 14;
  if (has_souttangentz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(14, this->souttangentz(), target);
  }
  
  // optional float fvalue1 = 15;
  if (has_fvalue1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(15, this->fvalue1(), target);
  }
  
  // optional float fvalue2 = 16;
  if (has_fvalue2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(16, this->fvalue2(), target);
  }
  
  // optional float fvalue3 = 17;
  if (has_fvalue3()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(17, this->fvalue3(), target);
  }
  
  // optional int32 ivalue1 = 18;
  if (has_ivalue1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(18, this->ivalue1(), target);
  }
  
  // repeated .aefilter.AEKeytimeEase easeValues = 19;
  for (int i = 0; i < this->easevalues_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        19, this->easevalues(i), target);
  }
  
  // optional bool isCookedKeytime = 20;
  if (has_iscookedkeytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(20, this->iscookedkeytime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AEKeytime::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .aefilter.AEDataType datatype = 1;
    if (has_datatype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->datatype());
    }
    
    // required float timeOffset = 2;
    if (has_timeoffset()) {
      total_size += 1 + 4;
    }
    
    // required .aefilter.AEIType inttype = 3;
    if (has_inttype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->inttype());
    }
    
    // optional float obsoleteSpeedIn = 5;
    if (has_obsoletespeedin()) {
      total_size += 1 + 4;
    }
    
    // optional float obsoleteInfluenceIn = 6;
    if (has_obsoleteinfluencein()) {
      total_size += 1 + 4;
    }
    
    // optional float obsoleteSpeedOut = 7;
    if (has_obsoletespeedout()) {
      total_size += 1 + 4;
    }
    
    // optional float obsoleteInfluenceOut = 8;
    if (has_obsoleteinfluenceout()) {
      total_size += 1 + 4;
    }
    
    // optional float sInTangentX = 9;
    if (has_sintangentx()) {
      total_size += 1 + 4;
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float sInTangentY = 10;
    if (has_sintangenty()) {
      total_size += 1 + 4;
    }
    
    // optional float sInTangentZ = 11;
    if (has_sintangentz()) {
      total_size += 1 + 4;
    }
    
    // optional float sOutTangentX = 12;
    if (has_souttangentx()) {
      total_size += 1 + 4;
    }
    
    // optional float sOutTangentY = 13;
    if (has_souttangenty()) {
      total_size += 1 + 4;
    }
    
    // optional float sOutTangentZ = 14;
    if (has_souttangentz()) {
      total_size += 1 + 4;
    }
    
    // optional float fvalue1 = 15;
    if (has_fvalue1()) {
      total_size += 1 + 4;
    }
    
    // optional float fvalue2 = 16;
    if (has_fvalue2()) {
      total_size += 2 + 4;
    }
    
    // optional float fvalue3 = 17;
    if (has_fvalue3()) {
      total_size += 2 + 4;
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional int32 ivalue1 = 18;
    if (has_ivalue1()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ivalue1());
    }
    
    // optional bool isCookedKeytime = 20;
    if (has_iscookedkeytime()) {
      total_size += 2 + 1;
    }
    
  }
  // repeated .aefilter.AEKeytimeEase easeValues = 19;
  total_size += 2 * this->easevalues_size();
  for (int i = 0; i < this->easevalues_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->easevalues(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AEKeytime::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AEKeytime* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AEKeytime*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AEKeytime::MergeFrom(const AEKeytime& from) {
  GOOGLE_CHECK_NE(&from, this);
  easevalues_.MergeFrom(from.easevalues_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_datatype()) {
      set_datatype(from.datatype());
    }
    if (from.has_timeoffset()) {
      set_timeoffset(from.timeoffset());
    }
    if (from.has_inttype()) {
      set_inttype(from.inttype());
    }
    if (from.has_obsoletespeedin()) {
      set_obsoletespeedin(from.obsoletespeedin());
    }
    if (from.has_obsoleteinfluencein()) {
      set_obsoleteinfluencein(from.obsoleteinfluencein());
    }
    if (from.has_obsoletespeedout()) {
      set_obsoletespeedout(from.obsoletespeedout());
    }
    if (from.has_obsoleteinfluenceout()) {
      set_obsoleteinfluenceout(from.obsoleteinfluenceout());
    }
    if (from.has_sintangentx()) {
      set_sintangentx(from.sintangentx());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_sintangenty()) {
      set_sintangenty(from.sintangenty());
    }
    if (from.has_sintangentz()) {
      set_sintangentz(from.sintangentz());
    }
    if (from.has_souttangentx()) {
      set_souttangentx(from.souttangentx());
    }
    if (from.has_souttangenty()) {
      set_souttangenty(from.souttangenty());
    }
    if (from.has_souttangentz()) {
      set_souttangentz(from.souttangentz());
    }
    if (from.has_fvalue1()) {
      set_fvalue1(from.fvalue1());
    }
    if (from.has_fvalue2()) {
      set_fvalue2(from.fvalue2());
    }
    if (from.has_fvalue3()) {
      set_fvalue3(from.fvalue3());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_ivalue1()) {
      set_ivalue1(from.ivalue1());
    }
    if (from.has_iscookedkeytime()) {
      set_iscookedkeytime(from.iscookedkeytime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AEKeytime::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AEKeytime::CopyFrom(const AEKeytime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AEKeytime::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  for (int i = 0; i < easevalues_size(); i++) {
    if (!this->easevalues(i).IsInitialized()) return false;
  }
  return true;
}

void AEKeytime::Swap(AEKeytime* other) {
  if (other != this) {
    std::swap(datatype_, other->datatype_);
    std::swap(timeoffset_, other->timeoffset_);
    std::swap(inttype_, other->inttype_);
    std::swap(obsoletespeedin_, other->obsoletespeedin_);
    std::swap(obsoleteinfluencein_, other->obsoleteinfluencein_);
    std::swap(obsoletespeedout_, other->obsoletespeedout_);
    std::swap(obsoleteinfluenceout_, other->obsoleteinfluenceout_);
    std::swap(sintangentx_, other->sintangentx_);
    std::swap(sintangenty_, other->sintangenty_);
    std::swap(sintangentz_, other->sintangentz_);
    std::swap(souttangentx_, other->souttangentx_);
    std::swap(souttangenty_, other->souttangenty_);
    std::swap(souttangentz_, other->souttangentz_);
    std::swap(fvalue1_, other->fvalue1_);
    std::swap(fvalue2_, other->fvalue2_);
    std::swap(fvalue3_, other->fvalue3_);
    std::swap(ivalue1_, other->ivalue1_);
    easevalues_.Swap(&other->easevalues_);
    std::swap(iscookedkeytime_, other->iscookedkeytime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AEKeytime::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AEKeytime_descriptor_;
  metadata.reflection = AEKeytime_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AETrack::kBindingFieldNumber;
const int AETrack::kTargetidFieldNumber;
const int AETrack::kTargetnameFieldNumber;
const int AETrack::kKeytimesFieldNumber;
const int AETrack::kTrackNameFieldNumber;
#endif  // !_MSC_VER

AETrack::AETrack()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AETrack::InitAsDefaultInstance() {
}

AETrack::AETrack(const AETrack& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AETrack::SharedCtor() {
  _cached_size_ = 0;
  binding_ = 0;
  targetid_ = 0;
  targetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  trackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AETrack::~AETrack() {
  SharedDtor();
}

void AETrack::SharedDtor() {
  if (targetname_ != &::google::protobuf::internal::kEmptyString) {
    delete targetname_;
  }
  if (trackname_ != &::google::protobuf::internal::kEmptyString) {
    delete trackname_;
  }
  if (this != default_instance_) {
  }
}

void AETrack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AETrack::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AETrack_descriptor_;
}

const AETrack& AETrack::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AETrack* AETrack::default_instance_ = NULL;

AETrack* AETrack::New() const {
  return new AETrack;
}

void AETrack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    binding_ = 0;
    targetid_ = 0;
    if (has_targetname()) {
      if (targetname_ != &::google::protobuf::internal::kEmptyString) {
        targetname_->clear();
      }
    }
    if (has_trackname()) {
      if (trackname_ != &::google::protobuf::internal::kEmptyString) {
        trackname_->clear();
      }
    }
  }
  keytimes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AETrack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .aefilter.AEBinding binding = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (aefilter::AEBinding_IsValid(value)) {
            set_binding(static_cast< aefilter::AEBinding >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_targetid;
        break;
      }
      
      // required int32 targetid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_targetid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &targetid_)));
          set_has_targetid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_targetname;
        break;
      }
      
      // required string targetname = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_targetname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_targetname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->targetname().data(), this->targetname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_keytimes;
        break;
      }
      
      // repeated .aefilter.AEKeytime keytimes = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_keytimes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_keytimes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_keytimes;
        if (input->ExpectTag(42)) goto parse_trackName;
        break;
      }
      
      // optional string trackName = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_trackName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_trackname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->trackname().data(), this->trackname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AETrack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .aefilter.AEBinding binding = 1;
  if (has_binding()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->binding(), output);
  }
  
  // required int32 targetid = 2;
  if (has_targetid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->targetid(), output);
  }
  
  // required string targetname = 3;
  if (has_targetname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->targetname().data(), this->targetname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->targetname(), output);
  }
  
  // repeated .aefilter.AEKeytime keytimes = 4;
  for (int i = 0; i < this->keytimes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->keytimes(i), output);
  }
  
  // optional string trackName = 5;
  if (has_trackname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->trackname().data(), this->trackname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->trackname(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AETrack::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .aefilter.AEBinding binding = 1;
  if (has_binding()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->binding(), target);
  }
  
  // required int32 targetid = 2;
  if (has_targetid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->targetid(), target);
  }
  
  // required string targetname = 3;
  if (has_targetname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->targetname().data(), this->targetname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->targetname(), target);
  }
  
  // repeated .aefilter.AEKeytime keytimes = 4;
  for (int i = 0; i < this->keytimes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->keytimes(i), target);
  }
  
  // optional string trackName = 5;
  if (has_trackname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->trackname().data(), this->trackname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->trackname(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AETrack::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .aefilter.AEBinding binding = 1;
    if (has_binding()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->binding());
    }
    
    // required int32 targetid = 2;
    if (has_targetid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->targetid());
    }
    
    // required string targetname = 3;
    if (has_targetname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->targetname());
    }
    
    // optional string trackName = 5;
    if (has_trackname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->trackname());
    }
    
  }
  // repeated .aefilter.AEKeytime keytimes = 4;
  total_size += 1 * this->keytimes_size();
  for (int i = 0; i < this->keytimes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->keytimes(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AETrack::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AETrack* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AETrack*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AETrack::MergeFrom(const AETrack& from) {
  GOOGLE_CHECK_NE(&from, this);
  keytimes_.MergeFrom(from.keytimes_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_binding()) {
      set_binding(from.binding());
    }
    if (from.has_targetid()) {
      set_targetid(from.targetid());
    }
    if (from.has_targetname()) {
      set_targetname(from.targetname());
    }
    if (from.has_trackname()) {
      set_trackname(from.trackname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AETrack::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AETrack::CopyFrom(const AETrack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AETrack::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  for (int i = 0; i < keytimes_size(); i++) {
    if (!this->keytimes(i).IsInitialized()) return false;
  }
  return true;
}

void AETrack::Swap(AETrack* other) {
  if (other != this) {
    std::swap(binding_, other->binding_);
    std::swap(targetid_, other->targetid_);
    std::swap(targetname_, other->targetname_);
    keytimes_.Swap(&other->keytimes_);
    std::swap(trackname_, other->trackname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AETrack::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AETrack_descriptor_;
  metadata.reflection = AETrack_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AEMarker::kStarttimeFieldNumber;
const int AEMarker::kDurationFieldNumber;
const int AEMarker::kNameFieldNumber;
const int AEMarker::kTracksSelectionFieldNumber;
const int AEMarker::kAlltracksFieldNumber;
const int AEMarker::kIdFieldNumber;
const int AEMarker::kLoopingFieldNumber;
#endif  // !_MSC_VER

AEMarker::AEMarker()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AEMarker::InitAsDefaultInstance() {
}

AEMarker::AEMarker(const AEMarker& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AEMarker::SharedCtor() {
  _cached_size_ = 0;
  starttime_ = 0;
  duration_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  alltracks_ = false;
  id_ = 0;
  looping_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AEMarker::~AEMarker() {
  SharedDtor();
}

void AEMarker::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void AEMarker::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AEMarker::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AEMarker_descriptor_;
}

const AEMarker& AEMarker::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AEMarker* AEMarker::default_instance_ = NULL;

AEMarker* AEMarker::New() const {
  return new AEMarker;
}

void AEMarker::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    starttime_ = 0;
    duration_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    alltracks_ = false;
    id_ = 0;
    looping_ = false;
  }
  tracksselection_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AEMarker::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float starttime = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &starttime_)));
          set_has_starttime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_duration;
        break;
      }
      
      // required float duration = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }
      
      // required string name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_tracksSelection;
        break;
      }
      
      // repeated .aefilter.AETrackIdentifier tracksSelection = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tracksSelection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tracksselection()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_tracksSelection;
        if (input->ExpectTag(40)) goto parse_alltracks;
        break;
      }
      
      // optional bool alltracks = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alltracks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &alltracks_)));
          set_has_alltracks();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_id;
        break;
      }
      
      // optional int32 id = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_looping;
        break;
      }
      
      // optional bool looping = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_looping:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &looping_)));
          set_has_looping();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AEMarker::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float starttime = 1;
  if (has_starttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->starttime(), output);
  }
  
  // required float duration = 2;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->duration(), output);
  }
  
  // required string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->name(), output);
  }
  
  // repeated .aefilter.AETrackIdentifier tracksSelection = 4;
  for (int i = 0; i < this->tracksselection_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->tracksselection(i), output);
  }
  
  // optional bool alltracks = 5;
  if (has_alltracks()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->alltracks(), output);
  }
  
  // optional int32 id = 6;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->id(), output);
  }
  
  // optional bool looping = 7;
  if (has_looping()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->looping(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AEMarker::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float starttime = 1;
  if (has_starttime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->starttime(), target);
  }
  
  // required float duration = 2;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->duration(), target);
  }
  
  // required string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->name(), target);
  }
  
  // repeated .aefilter.AETrackIdentifier tracksSelection = 4;
  for (int i = 0; i < this->tracksselection_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->tracksselection(i), target);
  }
  
  // optional bool alltracks = 5;
  if (has_alltracks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->alltracks(), target);
  }
  
  // optional int32 id = 6;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->id(), target);
  }
  
  // optional bool looping = 7;
  if (has_looping()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->looping(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AEMarker::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float starttime = 1;
    if (has_starttime()) {
      total_size += 1 + 4;
    }
    
    // required float duration = 2;
    if (has_duration()) {
      total_size += 1 + 4;
    }
    
    // required string name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional bool alltracks = 5;
    if (has_alltracks()) {
      total_size += 1 + 1;
    }
    
    // optional int32 id = 6;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // optional bool looping = 7;
    if (has_looping()) {
      total_size += 1 + 1;
    }
    
  }
  // repeated .aefilter.AETrackIdentifier tracksSelection = 4;
  total_size += 1 * this->tracksselection_size();
  for (int i = 0; i < this->tracksselection_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tracksselection(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AEMarker::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AEMarker* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AEMarker*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AEMarker::MergeFrom(const AEMarker& from) {
  GOOGLE_CHECK_NE(&from, this);
  tracksselection_.MergeFrom(from.tracksselection_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_starttime()) {
      set_starttime(from.starttime());
    }
    if (from.has_duration()) {
      set_duration(from.duration());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_alltracks()) {
      set_alltracks(from.alltracks());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_looping()) {
      set_looping(from.looping());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AEMarker::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AEMarker::CopyFrom(const AEMarker& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AEMarker::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  for (int i = 0; i < tracksselection_size(); i++) {
    if (!this->tracksselection(i).IsInitialized()) return false;
  }
  return true;
}

void AEMarker::Swap(AEMarker* other) {
  if (other != this) {
    std::swap(starttime_, other->starttime_);
    std::swap(duration_, other->duration_);
    std::swap(name_, other->name_);
    tracksselection_.Swap(&other->tracksselection_);
    std::swap(alltracks_, other->alltracks_);
    std::swap(id_, other->id_);
    std::swap(looping_, other->looping_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AEMarker::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AEMarker_descriptor_;
  metadata.reflection = AEMarker_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AETimeline::kTracksFieldNumber;
const int AETimeline::kMarkersFieldNumber;
#endif  // !_MSC_VER

AETimeline::AETimeline()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AETimeline::InitAsDefaultInstance() {
}

AETimeline::AETimeline(const AETimeline& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AETimeline::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AETimeline::~AETimeline() {
  SharedDtor();
}

void AETimeline::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AETimeline::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AETimeline::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AETimeline_descriptor_;
}

const AETimeline& AETimeline::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_AEFilter_2eproto();  return *default_instance_;
}

AETimeline* AETimeline::default_instance_ = NULL;

AETimeline* AETimeline::New() const {
  return new AETimeline;
}

void AETimeline::Clear() {
  tracks_.Clear();
  markers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AETimeline::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .aefilter.AETrack tracks = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tracks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tracks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_tracks;
        if (input->ExpectTag(18)) goto parse_markers;
        break;
      }
      
      // repeated .aefilter.AEMarker markers = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_markers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_markers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_markers;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AETimeline::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .aefilter.AETrack tracks = 1;
  for (int i = 0; i < this->tracks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->tracks(i), output);
  }
  
  // repeated .aefilter.AEMarker markers = 2;
  for (int i = 0; i < this->markers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->markers(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AETimeline::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .aefilter.AETrack tracks = 1;
  for (int i = 0; i < this->tracks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->tracks(i), target);
  }
  
  // repeated .aefilter.AEMarker markers = 2;
  for (int i = 0; i < this->markers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->markers(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AETimeline::ByteSize() const {
  int total_size = 0;
  
  // repeated .aefilter.AETrack tracks = 1;
  total_size += 1 * this->tracks_size();
  for (int i = 0; i < this->tracks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tracks(i));
  }
  
  // repeated .aefilter.AEMarker markers = 2;
  total_size += 1 * this->markers_size();
  for (int i = 0; i < this->markers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->markers(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AETimeline::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AETimeline* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AETimeline*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AETimeline::MergeFrom(const AETimeline& from) {
  GOOGLE_CHECK_NE(&from, this);
  tracks_.MergeFrom(from.tracks_);
  markers_.MergeFrom(from.markers_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AETimeline::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AETimeline::CopyFrom(const AETimeline& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AETimeline::IsInitialized() const {
  
  for (int i = 0; i < tracks_size(); i++) {
    if (!this->tracks(i).IsInitialized()) return false;
  }
  for (int i = 0; i < markers_size(); i++) {
    if (!this->markers(i).IsInitialized()) return false;
  }
  return true;
}

void AETimeline::Swap(AETimeline* other) {
  if (other != this) {
    tracks_.Swap(&other->tracks_);
    markers_.Swap(&other->markers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AETimeline::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AETimeline_descriptor_;
  metadata.reflection = AETimeline_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace aefilter

// @@protoc_insertion_point(global_scope)
#endif
#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning (pop)
#endif
